/* in thw "7-1 architecture" this main.scss file only serves to import other files 
@import "folder/file"; --> will import `folder/_file.scss` */
/* this file as the name suggests will be the base the styles will be build on top of. In here
 * you will set global resets, styles and normalizations */
/* basic "global" reset - affects all html elements including before and after pseudo-elements */
*,
*::after,
*::before {
  margin: 0;
  padding: 0;
  /* every element will inherit its box-sizing from its parent, which in this case will be the value
   * `box-sizing: border-box` set in <body>. Doing it this way (via inheritance) is considered a slightly
   * better approach than just setting it via the universal selector (I just dunno why) */
  box-sizing: inherit;
}

html {
  font-size: 62.5%; /* 62.5% * 16px (which is generally browser font-size) = 10 px, thus 1rem = 10px */
  /* rem is not supported bellow IE 9 */
}

body {
  /* everything related to "global" fonts should be done in the body tag selector, because
   * this way every element within <body> will inherit these style and its also more efficient
   * that doing the same via the `*` selector, which selects each element "individually", here
   * we're using the power of inheritance */
  box-sizing: border-box; /* margins and paddings are NOT added to the total size of the element */
}

/* in this file you should put all animations that'll be used in the project */
/* regarding browser performance, it's better to only ever animate the `opacity` and `transform` properties
 * because these only trigger the `composite` phase of rendering the element on screen, the other phases,
 * `style`, `layout` (of elements) and `paint` are skipped.
 *
 * of course you can animate other properties, but remember that browser animations are only optimized for
 * `opacity` and `transform`. This video `https://www.youtube.com/watch?v=N5EW4HnF6FU` demonstrates this in
 * practice.
 *
 * for example when you deal with an element's width or margin you're also messing with the positioning of
 * the elements next to it and because of that, animations with those become less performant and look bad. */
@keyframes moveInLeft {
  0% {
    opacity: 0; /* translateX repositions the element on the x axis relative to its initial position */
    transform: translateX(-10rem); /* the animation starts with the elem. 10rem (100px) to the left */
  }
  80% {
    transform: translateX(1rem);
  }
  100% {
    opacity: 1;
    transform: translateX(0); /* so the elem. is in its final position in the end of the animation */
  }
}
@keyframes moveInRight {
  0% {
    opacity: 0;
    transform: translateX(10rem); /* the animation starts with the elem. 10rem (100px) to the right */
  }
  80% {
    transform: translateX(-1rem);
  }
  100% {
    opacity: 1;
    transform: translateX(0); /* so the elem. is in its final position in the end of the animation */
  }
}
@keyframes moveInBottom {
  0% {
    opacity: 0;
    transform: translateY(3rem); /* the animation starts with the elem. 100px to the right */
  }
  100% {
    opacity: 1;
    transform: translateY(0); /* so the elem. is in its final position in the end of the animation */
  }
}
/* in this file you should put styles related to the general typography of the website */
body {
  font-family: "Lato", sans-serif; /* Use "Lato" font-family if available, otherwise use "sans-serif" */
  font-weight: 400;
  font-size: 1.6rem;
  line-height: 1.7; /* now line-height will be 1.7x bigger than the pre-defined line-height*/
  color: #777; /* sets text color */
  padding: 3rem; /* this padding will not be inherited by elements within <body> */
}

.heading-primary {
  color: #fff;
  text-transform: uppercase;
  /* maybe this is needed if animations (of child elements of this) flick, this prop somehow fixes it */
  backface-visibility: hidden;
  margin-bottom: 6rem;
}
.heading-primary--main {
  display: block;
  font-size: 6rem;
  font-weight: 400;
  letter-spacing: 3.5rem;
  animation-name: moveInLeft;
  animation-duration: 1.3s;
  animation-timing-function: ease-out;
  /*
  animation-delay: 3s; - delay for the animation to start
  animation-iteration-count: 3; - how many times should the animation be repeated
  */
}
.heading-primary--sub {
  display: block;
  font-size: 2rem;
  font-weight: 700;
  letter-spacing: 1.75rem;
  animation: moveInRight 1.3s ease-out; /* this is the shortcut for everything described bellow */
  /* animation-name: moveInRight;
  animation-duration: 1.3s;
  animation-timing-function: ease-out; */
}

.heading-secondary {
  display: inline-block;
  font-size: 3.5rem;
  text-transform: uppercase;
  font-weight: 700;
  background-image: linear-gradient(to right, #7ed56f, #28b485);
  /* by default the `background`(shortcut), `background-color` and `background-images` properties fill
   * the whole border-box, but via the `background-clip` property you can change this behavior to:
   * `padding-box`, `content-box` or `text`, so that the background you fill only this specific area. */
  background-clip: text;
  color: transparent;
  letter-spacing: 2px;
  transition: all 0.2s;
}
.heading-secondary:hover {
  transform: skewY(2deg) skewX(15deg) scale(1.1);
  text-shadow: 0.5rem 1rem 2rem rgba(0, 0, 0, 0.2);
}

.heading-tertiary {
  font-weight: 700;
  text-transform: uppercase;
}

.paragraph:not(:last-child) {
  margin-bottom: 3rem;
}

/* in this file you'll have utility classes which are generic classes that have a single
 * or simple style declaration that can be reused throughout the project */
/* while using !important is not a good practice at all, utility classes are an exception
 * to that, because as these will a lot of times be less specific that "normal" classes,
 * you don't care and just want that very specific style provided by the utility class
 * to be applied no matter what. */
.u-center-text {
  text-align: center !important;
}

.u-margin-bottom-extra-small {
  margin-bottom: 1rem !important;
}

.u-margin-bottom-small {
  margin-bottom: 2rem !important;
}

.u-margin-bottom-medium {
  margin-bottom: 4rem !important;
}

.u-margin-bottom-big {
  margin-bottom: 8rem !important;
}

.u-margin-top-extra-small {
  margin-top: 1rem !important;
}

.u-margin-top-small {
  margin-top: 2rem !important;
}

.u-margin-top-medium {
  margin-top: 4rem !important;
}

.u-margin-top-big {
  margin-top: 8rem !important;
}

.u-margin-top-huge {
  margin-top: 10rem !important;
}

.u-padding-left-small {
  padding-left: 1rem !important;
}

.u-pos-relative {
  position: relative !important;
}

.u-pos-absolute {
  position: absolute !important;
}

.btn {
  /* this `.btn` class was initially meant to be used only on <a> elements, so the "main" styles below
   * were all describe within `&:link, &:visited {...}` to account for visited and unvisited links.
   * Later on I found out that all styles defined for <a> also will be applied to the :visited and
   * :link naturally, unless they're overridden within these pseudo-class selectors. Second to that,
   * both of the states targeted by :visited and :link are comprised in the :any-link, so you can use
   * that instead. Finally, as this same `.btn` is now use in <button> elements, I've dropped :link
   * and :visited to the single `.btn` class selector so that all the main style are applied both to
   * <button> and <a>, <a>:visited and <a>:link.
   *
   * Use <a>:visited and <a>:link when you want to apply to style specifically to these states of <a>,
   * otherwise use <a> (or a class that will be directly assigned this element) */
  text-transform: uppercase;
  text-decoration: none; /* gets rid of that default underline in anchor tags text content */
  padding: 1.5rem 4rem;
  /* by setting `display: inline-block` the inner-display prop = `inline` and because of that you can treat
   * this element as text (so it can be easily centered if its parent element has `text-align: center` set).
   * the `inline-block` value is necessary so there is a box model for us to deal with margins and paddings... */
  display: inline-block;
  border-radius: 0.7rem;
  border: none;
  cursor: pointer;
  /* the `transition` property is a short-hand that will deal with the changing of style of an element,
   * so in the end it can be seen as another way to approach animations.
   * `transition` must always be set alongside the initial state styles.
   *
   * 1. define which css properties this transition will be applied to (if you don't know, use `all`)
   * 2. define the time this style transition will take (from initial state - define above - to final state
   *    which is in this case defined in `.btn:hover` and `.btn:active`) */
  transition: all 0.2s;
  position: relative;
  /* :active pseudo-class represents an anchor tag that is being clicked (left button of mouse pressed) */
  /* ::after is a pseudo-element, which are virtual elements that are inserted as child-elements from the
   * real html element, these will only appear on screen if they have `display` or `content` set, and you
   * also need to define its `height` and `width` (remember, as these are within the real html element,
   * the 100% value refers to the whole size of this element)
   *  */
}
.btn:hover {
  transform: translateY(-3px);
  box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.2); /* value = x-axis y-axis blur color */
  /* ::after pseudo-element when hovered */
}
.btn:hover::after {
  transform: scaleX(1.4) scaleY(1.6); /* scales this pseudo-element to twice its size */
  opacity: 0;
}
.btn:active, .btn:focus {
  transform: translateY(-1px);
  box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.2); /* value = x-axis y-axis blur color */
}
.btn--white {
  background-color: #fff;
  color: #777;
}
.btn--white::after {
  background-color: #fff;
}
.btn--green {
  background-color: #55c57a;
  color: #fff;
}
.btn--green::after {
  background-color: #55c57a;
}
.btn::after {
  content: ""; /* it just need to have `content` set, it can even be empty */
  display: inline-block;
  height: 100%; /* refers to 100% of the `.btn` element */
  width: 100%; /* refers to 100% of the `.btn` element */
  border-radius: 7px; /* used px because I don't want it to change based on browser font-size */
  position: absolute; /* this prop + `top: 0;` and `left: 0;` positions this pseudo-elem right over `.btn` */
  top: 0;
  left: 0;
  transition: all 0.4s;
  z-index: -1; /* so it hinds behind `.btn` */
}
.btn--white::after {
  background-color: #fff;
}
.btn--animated {
  /* animation: <animation-name> <animation-duration> <animation-timing-function> <animation-delay> */
  animation: moveInBottom 0.65s ease-out 0.75s;
  /* `backwards` value already applies styles define in the first `@keyframes` animation rules (0% in this
   * case), during `animation-delay` (.75s in this case). */
  animation-fill-mode: backwards;
}

.btn-text:link, .btn-text:visited {
  color: #55c57a;
  display: inline-block;
  text-decoration: none;
  border-bottom: 1px solid #55c57a;
  padding: 3px;
  border-radius: 5px;
  transition: all 0.3s ease-out;
}
.btn-text:hover, .btn-text:focus {
  background-color: #55c57a;
  color: #fff;
  box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.15);
  transform: translateY(-2px);
}
.btn-text:active {
  box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
  transform: translateY(0px);
}

.composition {
  position: relative;
  perspective: 700px;
  perspective-origin: 40% 0%;
  /* when .component is being hovered (i.e. when any element within .component container is being hovered),
   * selects all descendants from .component which are NOT being hovered at that moment.
   * final selector --> .component:hover .component__photo:not(:hover) */
}
.composition__photo {
  width: 80%;
  border-radius: 5px;
  position: absolute;
  transition: all 0.2s;
  outline-offset: 0.8rem;
}
.composition__photo--p1 {
  left: -5rem;
  transform: rotateX(80deg) rotateZ(15deg) rotateY(-5deg) scale(0.8);
  translate: 0px 0px -350px;
  box-shadow: 0 15px 40px rgba(0, 0, 0, 0.4);
}
.composition__photo--p2 {
  top: 2rem;
  left: 5rem;
  transform: rotateX(80deg) rotateZ(360deg) rotateY(-5deg) scale(0.9);
  translate: 10rem 0px -200px;
  box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4);
}
.composition__photo--p3 {
  top: 8rem;
  left: 10%;
  transform: rotateX(76deg) rotateZ(20deg) rotateY(352deg);
  box-shadow: 5px 15px 15px rgba(0, 0, 0, 0.5);
}
.composition__photo:hover {
  outline: 0.8rem solid #55c57a;
  transform: scale(1.05);
  translate: 0px 0px 0px;
  z-index: 1;
}
.composition:hover .composition__photo:not(:hover) {
  opacity: 0.7;
  scale: 0.9;
}

.feature-box {
  background-color: #d6e8da;
  padding: 2.5rem;
  text-align: center;
  border-radius: 3px;
  box-shadow: 0 1.5rem 4rem rgba(0, 0, 0, 0.15);
  transition-property: transform box-shadow;
  transition-duration: 0.2s;
  min-height: 38rem;
}
.feature-box__icon {
  font-size: 6rem;
  margin-bottom: 0.5rem;
  background-image: linear-gradient(to right, #7ed56f, #28b485);
  background-clip: text;
  color: transparent;
}
.feature-box:hover {
  transform: scale(1.05) translateY(-1.5rem);
  box-shadow: 0 1.5rem 4rem rgba(0, 0, 0, 0.35);
}

.card {
  perspective: 150rem;
  position: relative;
  height: 50rem;
  /* Why was it necessary to set a height above?
  *
  * It was necessary because all the child elements of div.card have `position: absolute` set
  * which makes them be removed from the `normal flow` (because of the creation of a new BFC),
  * thus the div.card element collapses (and becomes flat with with no height). Meanwhile, the
  * work around for this situations is setting a height manually (if needed).
  *
  * In this case, the best thing to do was to manually set the height to the same as the content
  * (div.card__side) mainly to use the :hover pseudo-class on that and avoid flickering of the
  * animation applied. */
  /* by hovering .card we rotate the child .card__side and this way we avoid animation flicker,
   * also, the :focus-within pseudo-class will turn the card when tab navigation focus on the
   * button placed on the back side of the card. */
  /* It was best not to nest it above because &__heading-span is an element itself and BEM methodology is
   * against the nesting of different elements, you can only nest those within blocks and within elements
   * you only nest modifiers */
}
.card__side {
  height: 50rem;
  transition: all 0.8s ease;
  position: absolute;
  top: 0;
  left: 0;
  backface-visibility: hidden;
  border-radius: 4px;
  overflow: hidden;
  box-shadow: 0 1.5rem 4rem rgba(0, 0, 0, 0.15);
  /* `width: 100%;` is needed because elements with `position: absolute` set have their width
  * defined by their content, I think it is `width: max-content;`. */
  width: 100%;
}
.card__side--front {
  background-color: #fff;
}
.card__side--back {
  rotate: y 180deg;
}
.card__side--back-1 {
  background-image: linear-gradient(to right bottom, #ffb900, #ff7730);
}
.card__side--back-2 {
  background-image: linear-gradient(to right bottom, #7ed56f, #28b485);
}
.card__side--back-3 {
  background-image: linear-gradient(to right bottom, #2998ff, #5643fa);
}
.card:hover .card__side--front, .card:focus-within .card__side--front {
  rotate: y -180deg;
}
.card:hover .card__side--back, .card:focus-within .card__side--back {
  rotate: y 0deg;
  /* hint: the value of `rotate` (or `transform: rotate()`) is the final position after the rotation,
   * so don't make a mistake and this that this value will be added to the final position after an
   * earlier rotation.
   * 
   * However, this is actually the case when the previous rotation has been performed by its "counter
   * part property", in this scenario the current rotation will start from the final position of the
   * last rotation. Taking the code above as example: 
   * 
   * // if .card__side--back was set like:
   * &--back {
   * color: white;
   * rotate: y 180deg;
   *
   * // then in .card:hover .card__side--back we could just add or remove 180deg to finish the this new
   * // rotation at 0deg:
   * &:hover &__side--back {
   *   transform: rotateY(180deg);
   * }
   */
}
.card__picture {
  height: 23rem;
  background-size: cover;
  background-position: center;
  background-blend-mode: screen;
  clip-path: polygon(0 0, 100% 0, 100% 85%, 0 100%);
}
.card__picture--1 {
  background-image: linear-gradient(to right bottom, #ffb900, #ff7730), url("../img/nat-5.jpg");
}
.card__picture--2 {
  background-image: linear-gradient(to right bottom, #7ed56f, #28b485), url("../img/nat-6.jpg");
}
.card__picture--3 {
  background-image: linear-gradient(to right bottom, #2998ff, #5643fa), url("../img/nat-7.jpg");
}
.card__heading {
  width: 15ch;
  font-size: 2.8rem;
  font-weight: 300;
  text-align: right;
  text-transform: uppercase;
  color: #fff;
  position: absolute;
  top: 12rem;
  right: 2rem;
}
.card__heading-span {
  padding: 1rem 1.5rem;
  /* `box-decoration-break: clone;` makes the breaks of an inline inline element be treated as different
   * boxes and thus applies styles as if each piece had it own box model */
  -webkit-box-decoration-break: clone;
  box-decoration-break: clone;
}
.card__heading-span--1 {
  background-image: linear-gradient(to right bottom, rgba(255, 185, 0, 0.85), rgba(255, 119, 48, 0.85));
}
.card__heading-span--2 {
  background-image: linear-gradient(to right bottom, rgba(126, 213, 111, 0.85), rgba(40, 180, 133, 0.85));
}
.card__heading-span--3 {
  background-image: linear-gradient(to right bottom, rgba(41, 152, 255, 0.85), rgba(86, 67, 250, 0.85));
}
.card__details ul {
  list-style: none;
  margin: 0 auto;
  width: 80%;
}
.card__details ul li {
  text-align: center;
  font-size: 1.5rem;
  padding: 1rem;
}
.card__details ul li:not(:last-child) {
  border-bottom: 1px solid #eee;
}
.card__cta {
  position: absolute;
  width: 100%;
  top: 50%;
  left: 50%;
  transform: translateX(-50%) translateY(-50%);
}
.card__price-box {
  transform-style: preserve-3d;
  color: #fff;
  margin-bottom: 8rem;
}
.card__price-only {
  font-size: 1.4rem;
  text-transform: uppercase;
}
.card__price-value {
  font-size: 6rem;
  font-weight: 300;
}

.story {
  width: 90%;
  margin: 0 auto;
  box-shadow: 0 30px 60px rgba(0, 0, 0, 0.1);
  background-color: rgba(255, 255, 255, 0.6);
  border-radius: 3px;
  padding: 6rem;
  transform: skewX(-12deg);
}
.story > * {
  transform: skewX(12deg);
}
.story__shape {
  width: 15rem;
  height: 15rem;
  float: left;
  margin-right: 3rem;
  shape-outside: circle(50%);
  clip-path: circle(50%);
  position: relative;
}
.story__img {
  height: 100%;
  transform: translateX(-40px) scale(1.2);
  transition: all 0.45s;
}
.story__caption {
  font-size: 1.7rem;
  color: #fff;
  text-transform: uppercase;
  text-align: center;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, 80%);
  opacity: 0;
  transition: all 0.45s;
}
.story:hover .story__caption {
  transform: translate(-50%, -50%);
  opacity: 1;
}
.story:hover .story__img {
  transform: translateX(-40px) scale(1);
  filter: blur(3px) brightness(80%);
}

.bg-video {
  position: absolute;
  width: 100%;
  height: 100%;
  opacity: 0.15;
  top: 0;
  left: 0;
  z-index: -1;
}
.bg-video__content {
  /* object-fit property values are: 
   * cover: covers the whole area and maintains the aspect ratio (some content clip may occur).
   * fill: covers the whole area but doesn't maintain the aspect ratio (no content clipping may occur).
   * contain: makes the element always be contained in its parent and maintains the aspect ratio,
   *          i.e. the element is always touching top/bottom or left/right (whichever is smaller),
   *          because it scales up or down as need to fit as a whole in the parent.
   * scale-down: just like `contain` value but the element only scales down, i.e. once it has
   *             reached its original size it won't scale up anymore, even if there is space to.
   * none: keeps the element's original size but makes sure it still fits its parent (i.e. clips
   *       what is overflowing, if needed, and also applies the value of `object-position`)
   *
   * As used bellow, the <video> content will cover 100% of the parent element height and width,
   * and also maintain its original aspect ratio. Width and height does NOT represent the video
   * dimensions, but the area this video must fit in its parent. 
   * 
   * object-fit property ONLY works alongside height and width (generally both 100%), if there
   * is only height or only width, it's like object-fit wasn't being applied and the content may
   * even overflow the parent (which is something that object-fit also solves for you). */
  height: 100%;
  width: 100%;
  object-fit: cover;
}

.form {
  /* while <input> placeholder is being shown, the associated <label> will be invisible
   * an translated upwards, so when it reappears (as the placeholder goes away), it will
   * be back to its original position in an animation as if the placeholder itself is
   * going down. */
}
.form__group:not(:last-child) {
  margin-bottom: 2rem;
}
.form__input {
  font-size: 1.5rem;
  /* <input> elements DON'T INHERIT the font properties, so it need to define it or
   * set it to inherit it's parent font-family value (this will also be used by the
   * form's placeholder text) */
  font-family: inherit;
  color: inherit;
  /* in form inputs horizontal padding tends to look smaller, so make it a bit
   * bigger to compensate for that and make it look better*/
  padding: 1.5rem 2rem;
  border-radius: 3px;
  background-color: rgba(255, 255, 255, 0.5);
  border-style: none;
  width: 100%;
  display: block;
  /* this transparent border is here just so that when we add a greenish border
   * as the user focuses on this <input> the elements below aren't moved around,
   * and that is because the border is already here but not showing yet. */
  border-bottom: 3px solid transparent;
  transition: border-bottom 0.2s;
  /* via the ::placeholder pseudo-element you can add rule sets specific to an
   * <input> placeholder, e.g. a different font color, a lighter one maybe. */
}
.form__input:focus {
  outline: none;
  box-shadow: 0 16px 20px rgba(0, 0, 0, 0.1);
  border-bottom: 3px solid #55c57a;
}
.form__input:focus:invalid {
  border-bottom: 3px solid #ff7730;
}
.form__input::placeholder {
  color: #999;
}
.form__label {
  font-size: 1.4rem;
  font-weight: 700;
  margin-left: 2rem;
  margin-top: 0.7rem;
  display: inline-block;
  opacity: 1;
  transition-property: transform opacity;
  transition-duration: 0.2s;
}
.form__input:placeholder-shown + .form__label {
  transform: translateY(-4.3rem);
  opacity: 0;
  visibility: hidden;
}
.form__radio-group {
  /* as we know there are only 2 radio buttons, `width: 49%;` + `display: inline-block;`
   * will make sure these are side by side in the layout. */
  width: 49%;
  display: inline-block;
}
.form__radio-input {
  /* so the actual <input type="radio"> which cannot be styled is removed from the layout
   * and also don't show on screen. It doesn't affect is functionality, by clicking the
   * <label> linked to this input, it will still be selected. */
  display: none;
}
.form__radio-label {
  cursor: pointer;
}
.form__radio-button {
  display: inline-block;
  vertical-align: middle;
  transform: translateY(-2px);
  height: 1.1rem;
  width: 1.1rem;
  border-radius: 50%;
  /* as there is no way (that I know of) to offset a border, I'll make the outer circle
   * of this radio button out of the outline property, which can be offset. As outline
   * doesn't take actual space in the page structure, i'm making up for that with a margin
   * that is the sum of the outline-width and outline-offset. */
  outline: 0.2rem solid #ff7730;
  /* if you're really going to use `outline-offset` on your project, it may be worth to
   * look for more details on the behavior of Google Chrome of not accepting non-whole 
   * pixel values for this property (I think it rounded these broken numbers down). */
  outline-offset: 0.3rem;
  margin: 0.5rem;
  /* In the Udemy css course, the instructor achieves the same using the border property
   * to represent the outer circle and makes the inner circle out of the border of the
   * ::after pseudo-element which is centered using `position: absolute`. I just found
   * my approach easier and simpler. In this case, the background-color will be animated
   * which is far from ideal, but it's an area so small that there show be unnoticeable
   * performance wise. */
  transition: background-color 0.2s;
}
.form__radio-input:checked + .form__radio-label .form__radio-button {
  background-color: #ff7730;
}

.navigation__checkbox {
  display: none;
}
.navigation__checkbox:checked ~ .navigation__background {
  transform: scale(90);
}
.navigation__checkbox:checked ~ .navigation__nav {
  opacity: 1;
  visibility: visible;
  transform: translate(0);
}
.navigation__button {
  height: 7rem;
  width: 7rem;
  border-radius: 50%;
  position: fixed;
  z-index: 1002;
  top: 6rem;
  right: 6rem;
  background-color: #fff;
  cursor: pointer;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
}
.navigation__background {
  height: 6rem;
  width: 6rem;
  border-radius: 50%;
  position: fixed;
  z-index: 1000;
  top: 6.5rem;
  right: 6.5rem;
  /* While `linear-gradient` goes from side to side, the `radial-gradient` starts at the center
   * and expands outwards. first you define the color in the center and after the outer color */
  background-image: radial-gradient(#7ed56f, #28b485);
  transition: transform 0.8s cubic-bezier(0.83, 0, 0.17, 1);
}
.navigation__nav {
  height: 100vh;
  width: 100vw;
  position: fixed;
  z-index: 1001;
  top: 0;
  left: 0;
  opacity: 0;
  visibility: hidden;
  transform: translateX(-400px);
  transition: opacity 0.4s cubic-bezier(0.46, 0, 0.36, 0), transform 0.5s cubic-bezier(0.68, -0.6, 0.32, 1.6);
  transition-delay: 0.2s;
}
.navigation__list {
  list-style: none;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  text-align: center;
}
.navigation__item {
  margin: 1rem;
}
.navigation__link {
  display: inline-block;
  font-size: 3rem;
  font-weight: 300;
  padding: 1rem 2rem;
  color: #fff;
  text-decoration: none;
  text-transform: uppercase;
  background-image: linear-gradient(120deg, transparent 0%, transparent 50%, #fff 50%);
  background-size: 225%;
  transition: all 0.3s;
}
.navigation__link span {
  margin-right: 1.5rem;
}
.navigation__link:hover, .navigation__link:active, .navigation__link:focus {
  /* when a percentage is used like that (below), the background X coordinate goes to the percentage
   * with a Y coordinate set to 50%. So in the end, the thick is: expand the "solid part" of the
   * background until it disappears (as done above) and then, on hover, focus and active, bring the
   * background-position to 100% so the solid part of it reappears. */
  background-position: 100%;
  color: #55c57a;
  transform: translateX(1rem);
}

.header {
  /* the calc is to make it fits the viewport with 30px of padding above and bellow (added in <body>) */
  height: calc(98vh - (60px - 2vh)); /* 98% of the viewport height (60px is for 2 * <body> padding (30px)) */
  /* always apply a gradient on the background via the `background-image` css prop, and if its the case
   * define the actual bg image afterwards, this way the gradient will be on top of the image - make sure
   * to correctly adjust the gradient opacity */
  background-image: linear-gradient(to right bottom, rgba(126, 213, 111, 0.8), rgba(40, 180, 133, 0.8)), url("../img/hero.jpg");
  background-size: cover; /* directly on replaced elements, e.g. <img>, <video>, you can use `object-fit` */
  background-position: top; /* tells which part of the bg should be "fixed" and will never go out of the frame */
  /* clip-path apply a "mask" in the object, you define the coordinate based on what you want to be shown on
   * screen - the `polygon` function receives coordinates to create as polygon shaped mask.
   * Fortunately, coordinates can be dynamic and passed as percentages */
  clip-path: polygon(0 0, 100% 0, 100% 75vh, 0 100%);
  /* position: relative; is like `static` but respects reference values from `top`, `left`, `bottom` and `right`,
   * and also can be used as "anchor" to child elements which have `position: absolute` */
  position: relative;
}
.header__logo-box {
  position: absolute;
  top: 4rem; /* relative to it's closest positioned parent, `.header` in this case */
  left: 4rem; /* relative to it's closest positioned parent, `.header` in this case */
}
.header__logo {
  height: 3.5rem; /* by just setting `height` and omitting the `width`, this prop will be automatically figured out */
}
.header__text-box {
  /* When you want to symmetrically center an element, just use flexbox prop on parents and child elements, but when
   * it's not gonna be 100% symmetrical, that's how you do it: */
  position: absolute; /* now it's positioned relative to it's closest positioned parent */
  top: 40%; /* relative to `.header` */
  left: 50%; /* relative to `.header` */
  /* as the element is positioned based on its top left corner, the prop bellow "makes it" be positioned based on
   * the element's center. Relative to the element's own position, it repositions it 50% (of its length) to the left
   * and 50% (of its height) to the top */
  transform: translate(-50%, -50%);
  text-align: center; /* this will make sure `.btn` element is centered */
}

/* Even though floats are not used anymore, it may be interesting to still know how these
 * work in case you have to update an old website that uses it to newer technologies */
.row {
  display: flow-root;
  max-width: 114rem;
  margin: 0 auto;
  /* I don't want this padding to change according to root font-size because in case its a bigger
   * font-size this padding would also become bigger and thus squash letters even more. */
  padding: 0 16px;
  /* [class^="col-"] selects all elements whose class attribute value starts with "col-"
   * actually is the `^` symbol that does this trick.
   * `^` --> starts with the declared value
   * `*` --> contains the declared value
   * `$` --> ends with the declared value */
}
.row:not(:last-child) {
  margin-bottom: 8rem;
}
.row [class^=col-] {
  float: left;
}
.row [class^=col-]:not(:last-child) {
  margin-right: 6rem;
}
.row .col-1-of-2 {
  /* no need to use # + { <var-here> } within `calc()` in dart-sass@1.72.0 */
  width: calc((100% - 6rem) / 2);
}
.row .col-1-of-3 {
  width: calc(calc(100% - 12rem)/3 * 1 + 0rem);
}
.row .col-2-of-3 {
  width: calc(calc(100% - 12rem)/3 * 2 + 6rem);
}
.row .col-1-of-4 {
  width: calc(calc(100% - 18rem)/4 * 1 + 0rem);
}
.row .col-2-of-4 {
  width: calc(calc(100% - 18rem)/4 * 2 + 6rem);
}
.row .col-3-of-4 {
  width: calc(calc(100% - 18rem)/4 * 3 + 12rem);
}

.footer {
  background-color: #333;
  padding: 10rem 0;
  font-size: 1.4rem;
  color: #f7f7f7;
}
.footer__logo-box {
  text-align: center;
  margin-bottom: 8rem;
}
.footer__logo {
  width: 15rem;
}
.footer__navigation {
  border-top: 1px solid #777;
  padding-top: 2rem;
}
.footer__list {
  list-style: none;
  text-align: center;
}
.footer__item {
  display: inline-block;
}
.footer__item:not(:last-child) {
  margin-right: 2rem;
}
.footer__link {
  background-color: #333;
  text-decoration: none;
  text-transform: uppercase;
  color: inherit;
  display: inline-block;
  transition: transform 150ms;
}
.footer__link:hover, .footer__link:active, .footer__link:focus {
  color: #55c57a;
  box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4);
  transform: rotate(5deg) scale(1.3);
}
.footer__copyright {
  padding-top: 2rem;
  border-top: 1px solid #777;
  width: 80%;
  margin-left: auto;
}

/* in scss files within the pages folder (like this file), we can put style that could
 * be in the components folder but actually are going to appear only in this specific page */
.section-about {
  background-color: #f7f7f7;
  /* 8rem is the padding we want and +$margin-negative-indentation is to "cancel out" the
   * negative margin-top property set just bellow. In the end we're just doing that so the
   * background color of this element "flows" behind the element above this one.
   * (I looks like a hack to me, maybe there is a better way to do that...) */
  padding: calc(8rem + 20vh) 0 20vh;
  /* when you use negative values for margin instead of "expanding" outwards and pushing elements
   * around, it "expands" inwards and this way its box model gets smaller, thus the element gets
   * closer to other elements */
  margin-top: -20vh;
}

.section-features {
  padding: 15rem 0;
  background-image: linear-gradient(to right bottom, rgba(126, 213, 111, 0.8), rgba(40, 180, 133, 0.8)), url("../img/nat-4.jpg");
  background-size: cover;
  margin-top: -12rem;
  transform: skewY(-7deg);
}
.section-features > * {
  transform: skewY(7deg);
}

.section-tours {
  padding: calc(12rem + 8rem) 0 8rem;
  background-color: #f7f7f7;
  margin-top: -12rem;
}

.section-stories {
  position: relative;
  padding: 15rem 0;
}

.section-book {
  padding: 15rem 0;
  background-image: linear-gradient(to right bottom, #7ed56f, #28b485);
}

.book {
  /* regarding `linear-gradient()` its direction can be set in degrees also, and you can define a percentages
   * referring after the color which will represent where it begins or ends, e.g. below the a gradient that
   * starts at 0% in white and goes up to 50%, and from there up to the end it its transparent so the actual
   * background image can show. */
  background-image: linear-gradient(105deg, rgba(255, 255, 255, 0.85) 0%, rgba(255, 255, 255, 0.85) 50%, transparent 50%), url("../img/nat-10.jpg");
  background-size: cover;
  background-position: right;
  border-radius: 4px;
  box-shadow: 0 15px 40px rgba(0, 0, 0, 0.2);
}
.book__form {
  width: 50%;
  padding: 6rem;
  padding-bottom: 4rem;
}

/*# sourceMappingURL=style.css.map */
