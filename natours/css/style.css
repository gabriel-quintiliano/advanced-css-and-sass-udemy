/* in thw "7-1 architecture" this main.scss file only serves to import other files 
@import "folder/file"; --> will import `folder/_file.scss` */
/*
0-600px:       phone (max-width)
601-900px:     Tablet portrait (max-width)
901-1200px:    Tablet landscape (max-width)
[1201-1800px]: where the normal css already applies (base)
1801px + :     Big desktop (min-width)
*/
/* In sass you can use media queries directly within the selector, while in plain css
 * the selector must be encapsulated by the media query, this alone can make it all more
 * organized and specific, but there are even better way to implement it... 
 *
 * To use media queries in a more efficient way which is powered by sass, make these into
 * reusable mixins, this way you can still define several media queries in several different
 * .scss files (which makes it all more organized and specific), but if you ever want to
 * change any of the breakpoints you'll only deal with the media query declaration within
 * the corresponding mixin, hence it's much more scalable. Traditionally, there is a single
 * big ass media query which holds every style specific for that breakpoint, but no need to
 * do that in sass. */
/* The @content directive make it possible for the mixin take a declaration block and in the
 * compiling process replace @content for that block. */
/* $breakpoint argument choices:
 * - phone 
 * - tab-port
 * - tab-land
 * - big-desktop
 *
 * ORDER: Base + typography > general layout > grid > page-layout > components
 *
 * 1 em = 16px by default */
/* Media queries only take into account the font-size set up in the browser itself, what
 * is set up in :root or html makes no difference. And also, use `em` instead of `rem`
 * because `em` have better support in media queries and regarding sizes, there will be
 * no difference in this case, both relate to the default font-size of the browser. */
/* As done above, it's a pretty good idea to use `em` instead of `px` in your media query
 * breakpoints because this way, when the user has, for example, a bigger font-size set up
 * in their browser, this will also be taken into account to make the style of that media
 * query apply or not. Say that the user has the default font-size set to 24px, now 37.5em
 * is not 600px anymore, it's 900px, so in this case, even in a 900px display the user will
 * have the same layout as a 600px phone layout (with font-size 16px), which makes sense as
 * the content itself will appear bigger. */
/* this file as the name suggests will be the base the styles will be build on top of. In here
 * you will set global resets, styles and normalizations */
/* basic "global" reset - affects all html elements including before and after pseudo-elements */
*,
*::after,
*::before {
  margin: 0;
  padding: 0;
  /* every element will inherit its box-sizing from its parent, which in this case will be the value
   * `box-sizing: border-box` set in <body>. Doing it this way (via inheritance) is considered a slightly
   * better approach than just setting it via the universal selector (I just dunno why) */
  box-sizing: inherit;
}

html {
  font-size: 62.5%;
  /* rem is not supported bellow IE 9 */
}
@media screen and (max-width: 75em) {
  html {
    font-size: 56.25%;
  }
}
@media screen and (max-width: 56.25em) {
  html {
    font-size: 50%;
  }
}
@media screen and (min-width: 112.5em) {
  html {
    font-size: 75%;
  }
}

body {
  /* everything related to "global" fonts should be done in the body tag selector, because
   * this way every element within <body> will inherit these style and its also more efficient
   * that doing the same via the `*` selector, which selects each element "individually", here
   * we're using the power of inheritance */
  box-sizing: border-box; /* margins and paddings are NOT added to the total size of the element */
  padding: 3rem; /* this padding will not be inherited by elements within <body> */
}
@media screen and (max-width: 56.25em) {
  body {
    padding: 0;
  }
}

::selection {
  background-color: #55c57a;
  color: #fff;
}

/* in this file you should put all animations that'll be used in the project */
/* regarding browser performance, it's better to only ever animate the `opacity` and `transform` properties
 * because these only trigger the `composite` phase of rendering the element on screen, the other phases,
 * `style`, `layout` (of elements) and `paint` are skipped.
 *
 * of course you can animate other properties, but remember that browser animations are only optimized for
 * `opacity` and `transform`. This video `https://www.youtube.com/watch?v=N5EW4HnF6FU` demonstrates this in
 * practice.
 *
 * for example when you deal with an element's width or margin you're also messing with the positioning of
 * the elements next to it and because of that, animations with those become less performant and look bad. */
@keyframes moveInLeft {
  0% {
    opacity: 0; /* translateX repositions the element on the x axis relative to its initial position */
    transform: translateX(-10rem); /* the animation starts with the elem. 10rem (100px) to the left */
  }
  80% {
    transform: translateX(1rem);
  }
  100% {
    opacity: 1;
    transform: translateX(0); /* so the elem. is in its final position in the end of the animation */
  }
}
@keyframes moveInRight {
  0% {
    opacity: 0;
    transform: translateX(10rem); /* the animation starts with the elem. 10rem (100px) to the right */
  }
  80% {
    transform: translateX(-1rem);
  }
  100% {
    opacity: 1;
    transform: translateX(0); /* so the elem. is in its final position in the end of the animation */
  }
}
@keyframes moveInBottom {
  0% {
    opacity: 0;
    transform: translateY(3rem); /* the animation starts with the elem. 100px to the right */
  }
  100% {
    opacity: 1;
    transform: translateY(0); /* so the elem. is in its final position in the end of the animation */
  }
}
/* in this file you should put styles related to the general typography of the website */
body {
  font-family: "Lato", sans-serif; /* Use "Lato" font-family if available, otherwise use "sans-serif" */
  font-weight: 400;
  font-size: 1.6rem;
  line-height: 1.7; /* now line-height will be 1.7x bigger than the pre-defined line-height*/
  color: #777; /* sets text color */
}

.heading-primary {
  color: #fff;
  text-transform: uppercase;
  /* maybe this is needed if animations (of child elements of this) flick, this prop somehow fixes it */
  backface-visibility: hidden;
  margin-bottom: 6rem;
}
.heading-primary--main {
  display: block;
  font-size: 6rem;
  font-weight: 400;
  letter-spacing: 3.5rem;
  animation-name: moveInLeft;
  animation-duration: 1.3s;
  animation-timing-function: ease-out;
  /*
  animation-delay: 3s; - delay for the animation to start
  animation-iteration-count: 3; - how many times should the animation be repeated
  */
}
@media screen and (max-width: 37.5em) {
  .heading-primary--main {
    letter-spacing: 1rem;
    font-size: 5rem;
  }
}
.heading-primary--sub {
  display: block;
  font-size: 2rem;
  font-weight: 700;
  letter-spacing: 1.75rem;
  animation: moveInRight 1.3s ease-out; /* this is the shortcut for everything described bellow */
  /* animation-name: moveInRight;
  animation-duration: 1.3s;
  animation-timing-function: ease-out; */
}
@media screen and (max-width: 37.5em) {
  .heading-primary--sub {
    letter-spacing: 0.5rem;
    font-size: 1.7rem;
  }
}

.heading-secondary {
  display: inline-block;
  font-size: 3.5rem;
  text-transform: uppercase;
  font-weight: 700;
  background-image: linear-gradient(to right, #7ed56f, #28b485);
  /* by default the `background`(shortcut), `background-color` and `background-images` properties fill
   * the whole border-box, but via the `background-clip` property you can change this behavior to:
   * `padding-box`, `content-box` or `text`, so that the background you fill only this specific area. */
  background-clip: text;
  color: transparent;
  letter-spacing: 2px;
  transition: all 0.2s;
}
@media screen and (max-width: 56.25em) {
  .heading-secondary {
    font-size: 3rem;
  }
}
@media screen and (max-width: 37.5em) {
  .heading-secondary {
    font-size: 2.5rem;
  }
}
.heading-secondary:hover {
  transform: skewY(2deg) skewX(15deg) scale(1.1);
  text-shadow: 0.5rem 1rem 2rem rgba(0, 0, 0, 0.2);
}

.heading-tertiary {
  font-weight: 700;
  text-transform: uppercase;
}

.paragraph:not(:last-child) {
  margin-bottom: 3rem;
}

/* in this file you'll have utility classes which are generic classes that have a single
 * or simple style declaration that can be reused throughout the project */
/* while using !important is not a good practice at all, utility classes are an exception
 * to that, because as these will a lot of times be less specific that "normal" classes,
 * you don't care and just want that very specific style provided by the utility class
 * to be applied no matter what. */
.u-center-text {
  text-align: center !important;
}

.u-margin-bottom-extra-small {
  margin-bottom: 1rem !important;
}

.u-margin-bottom-small {
  margin-bottom: 2rem !important;
}

.u-margin-bottom-medium {
  margin-bottom: 4rem !important;
}

.u-margin-bottom-big {
  margin-bottom: 8rem !important;
}

.u-margin-top-extra-small {
  margin-top: 1rem !important;
}

.u-margin-top-small {
  margin-top: 2rem !important;
}

.u-margin-top-medium {
  margin-top: 4rem !important;
}

.u-margin-top-big {
  margin-top: 8rem !important;
}

.u-margin-top-huge {
  margin-top: 10rem !important;
}

.u-padding-left-small {
  padding-left: 1rem !important;
}

.u-pos-relative {
  position: relative !important;
}

.u-pos-absolute {
  position: absolute !important;
}

@media screen and (max-width: 56.25em) {
  .u-margin-bottom-medium {
    margin-bottom: 3rem !important;
  }
  .u-margin-bottom-big {
    margin-bottom: 6rem !important;
  }
  .u-margin-top-medium {
    margin-top: 3rem !important;
  }
  .u-margin-top-big {
    margin-top: 6rem !important;
  }
  .u-margin-top-huge {
    margin-top: 8rem !important;
  }
}
.btn {
  /* this `.btn` class was initially meant to be used only on <a> elements, so the "main" styles below
   * were all describe within `&:link, &:visited {...}` to account for visited and unvisited links.
   * Later on I found out that all styles defined for <a> also will be applied to the :visited and
   * :link naturally, unless they're overridden within these pseudo-class selectors. Second to that,
   * both of the states targeted by :visited and :link are comprised in the :any-link, so you can use
   * that instead. Finally, as this same `.btn` is now use in <button> elements, I've dropped :link
   * and :visited to the single `.btn` class selector so that all the main style are applied both to
   * <button> and <a>, <a>:visited and <a>:link.
   *
   * Use <a>:visited and <a>:link when you want to apply to style specifically to these states of <a>,
   * otherwise use <a> (or a class that will be directly assigned this element) */
  text-transform: uppercase;
  text-decoration: none; /* gets rid of that default underline in anchor tags text content */
  padding: 1.5rem 4rem;
  /* by setting `display: inline-block` the inner-display prop = `inline` and because of that you can treat
   * this element as text (so it can be easily centered if its parent element has `text-align: center` set).
   * the `inline-block` value is necessary so there is a box model for us to deal with margins and paddings... */
  display: inline-block;
  border-radius: 0.7rem;
  border: none;
  cursor: pointer;
  /* the `transition` property is a short-hand that will deal with the changing of style of an element,
   * so in the end it can be seen as another way to approach animations.
   * `transition` must always be set alongside the initial state styles.
   *
   * 1. define which css properties this transition will be applied to (if you don't know, use `all`)
   * 2. define the time this style transition will take (from initial state - define above - to final state
   *    which is in this case defined in `.btn:hover` and `.btn:active`) */
  transition: all 0.2s;
  position: relative;
  /* :active pseudo-class represents an anchor tag that is being clicked (left button of mouse pressed) */
  /* ::after is a pseudo-element, which are virtual elements that are inserted as child-elements from the
   * real html element, these will only appear on screen if they have `display` or `content` set, and you
   * also need to define its `height` and `width` (remember, as these are within the real html element,
   * the 100% value refers to the whole size of this element)
   *  */
}
.btn:hover {
  transform: translateY(-3px);
  box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.2); /* value = x-axis y-axis blur color */
  /* ::after pseudo-element when hovered */
}
.btn:hover::after {
  transform: scaleX(1.4) scaleY(1.6); /* scales this pseudo-element to twice its size */
  opacity: 0;
}
.btn:active, .btn:focus {
  transform: translateY(-1px);
  box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.2); /* value = x-axis y-axis blur color */
}
.btn--white {
  background-color: #fff;
  color: #777;
}
.btn--white::after {
  background-color: #fff;
}
.btn--green {
  background-color: #55c57a;
  color: #fff;
}
.btn--green::after {
  background-color: #55c57a;
}
.btn::after {
  content: ""; /* it just need to have `content` set, it can even be empty */
  display: inline-block;
  height: 100%; /* refers to 100% of the `.btn` element */
  width: 100%; /* refers to 100% of the `.btn` element */
  border-radius: 7px; /* used px because I don't want it to change based on browser font-size */
  position: absolute; /* this prop + `top: 0;` and `left: 0;` positions this pseudo-elem right over `.btn` */
  top: 0;
  left: 0;
  transition: all 0.4s;
  z-index: -1; /* so it hinds behind `.btn` */
}
.btn--white::after {
  background-color: #fff;
}
.btn--animated {
  /* animation: <animation-name> <animation-duration> <animation-timing-function> <animation-delay> */
  animation: moveInBottom 0.65s ease-out 0.75s;
  /* `backwards` value already applies styles define in the first `@keyframes` animation rules (0% in this
   * case), during `animation-delay` (.75s in this case). */
  animation-fill-mode: backwards;
}

.btn-text:link, .btn-text:visited {
  color: #55c57a;
  display: inline-block;
  text-decoration: none;
  border-bottom: 1px solid #55c57a;
  padding: 3px;
  border-radius: 5px;
  transition: all 0.3s ease-out;
}
.btn-text:hover, .btn-text:focus {
  background-color: #55c57a;
  color: #fff;
  box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.15);
  transform: translateY(-2px);
}
.btn-text:active {
  box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
  transform: translateY(0px);
}

.btn-close {
  --_btn-close-size: 3.7rem;
  padding: 0;
  margin: 0;
  font-size: var(--_btn-close-size);
  width: var(--_btn-close-size);
  height: var(--_btn-close-size);
  background-color: #55c57a;
  border-radius: 50%;
  text-align: center;
  line-height: calc(var(--_btn-close-size) - 0.4rem);
  color: white;
}
@media screen and (max-width: 37.5em) {
  .btn-close {
    --_btn-close-size: 4.7rem;
  }
}

.composition {
  --_photo-transition-duration: .2s;
  --_p1-left: -5rem;
  --_p3-top: 8rem;
  --_p3-translate: 0;
  position: relative;
  perspective: 700px;
  perspective-origin: 40% 0%;
  background-color: lightblue;
  /* when .component is being hovered (i.e. when any element within .component container is being hovered),
   * selects all descendants from .component which are NOT being hovered at that moment.
   * final selector --> .component:hover .component__photo:not(:hover) */
}
@media screen and (max-width: 56.25em) {
  .composition {
    /* I used margin-bottom here to give .composition some height (29rem in this case). As
     * there are only absolutely positioned elements within, this container collapses, but
     * it turns out that in phone and tab-port 1 column layout, the absolutely positioned
     * elements will occupy no actual space in the normal flow and that's what margin-bottom
     * is solving now.
     *
     * Why margin-bottom instead of height? that is because of the hover effect applied in
     * `&:hover &__photo:not(:hover) {...}`, for it to work properly, the actual composition
     * element has to have no height, otherwise, when it being hovered the scale and opacity
     * styles will be applied to all the photos, which is weird when no specific photo is
     * being hovered. This selector mentioned above is just to select the photos not being
     * hovered when there is actually another photo already being hovered. */
    margin-bottom: 29rem;
    transform: translateY(-65px);
    --_p1-left: 10%;
    --_p3-top: 0;
    --_p3-translate: 0 6rem 0;
  }
}
@media screen and (max-width: 37.5em) {
  .composition {
    --_photo-transition-duration: 270ms;
  }
}
.composition__photo {
  width: 80%;
  border-radius: 5px;
  position: absolute;
  transition: all var(--_photo-transition-duration);
  outline-offset: 0.8rem;
}
.composition__photo--p1 {
  left: var(--_p1-left);
  transform: rotateX(80deg) rotateZ(15deg) rotateY(-5deg) scale(0.8);
  translate: 0px 0px -350px;
  box-shadow: 0 15px 40px rgba(0, 0, 0, 0.4);
}
.composition__photo--p2 {
  top: 2rem;
  left: 5rem;
  transform: rotateX(80deg) rotateZ(360deg) rotateY(-5deg) scale(0.9);
  translate: 10rem 0px -200px;
  box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4);
}
.composition__photo--p3 {
  top: var(--_p3-top);
  left: 10%;
  transform: rotateX(76deg) rotateZ(20deg) rotateY(352deg);
  translate: var(--_p3-translate);
  box-shadow: 5px 15px 15px rgba(0, 0, 0, 0.5);
}
.composition__photo:hover {
  outline: 0.8rem solid #55c57a;
  transform: scale(1.05);
  translate: 0px 0px 0px;
  z-index: 1;
}
.composition:hover .composition__photo:not(:hover) {
  opacity: 0.7;
  scale: 0.9;
}

.feature-box {
  --_fb-min-height: 38rem;
  --_extra-padding-bottom: 0rem;
  background-color: #d6e8da;
  padding: 2.5rem;
  padding-bottom: calc(2.5rem + var(--_extra-padding-bottom));
  text-align: center;
  border-radius: 3px;
  box-shadow: 0 1.5rem 4rem rgba(0, 0, 0, 0.15);
  transition-property: transform box-shadow;
  transition-duration: 0.2s;
  min-height: var(--_fb-min-height);
}
@media screen and (max-width: 56.25em) {
  .feature-box {
    --_fb-min-height: 0;
    --_extra-padding-bottom: 1rem;
  }
}
.feature-box__icon {
  font-size: 6rem;
  margin-bottom: 0.5rem;
  background-image: linear-gradient(to right, #7ed56f, #28b485);
  background-clip: text;
  color: transparent;
}
.feature-box:hover {
  transform: scale(1.05) translateY(-1.5rem);
  box-shadow: 0 1.5rem 4rem rgba(0, 0, 0, 0.35);
}

.card {
  --_card-height: 50rem;
  --_cs-height: 50rem;
  --_card-bg-color: transparent;
  --_cs-position: absolute;
  --_cs-front-y-rotation: -180deg;
  --_cs-back-y-rotation: 180deg;
  --_cs-back-clip-path: none;
  --_card-box-shadow: none;
  --_cs-box-shadow: 0 1.5rem 4rem rgba(0, 0, 0, 0.15);
  --_cta-position: absolute;
  --_cta-translate: translate(-50%, -50%);
  --_cta-padding-block: 0;
  --_price-box-margin-bottom: 8rem;
  background-color: var(--_card-bg-color);
  box-shadow: var(--_card-box-shadow);
  perspective: 150rem;
  position: relative;
  height: var(--_card-height);
  /* Why was it necessary to set a height above?
  *
  * It was necessary because all the child elements of div.card have `position: absolute` set
  * which makes them be removed from the `normal flow` (because of the creation of a new BFC),
  * thus the div.card element collapses (and becomes flat with with no height). Meanwhile, the
  * work around for this situations is setting a height manually (if needed).
  *
  * In this case, the best thing to do was to manually set the height to the same as the content
  * (div.card__side) mainly to use the :hover pseudo-class on that and avoid flickering of the
  * animation applied. */
  /* by hovering .card we rotate the child .card__side and this way we avoid animation flicker,
   * also, the :focus-within pseudo-class will turn the card when tab navigation focus on the
   * button placed on the back side of the card. */
  /* It was best not to nest it above because &__heading-span is an element itself and BEM methodology is
   * against the nesting of different elements, you can only nest those within blocks and within elements
   * you only nest modifiers */
}
@media screen and (max-width: 56.25em) {
  .card {
    --_card-height: auto;
    --_cs-height: auto;
    --_card-bg-color: #fff;
    --_cs-position: relative;
    --_cs-back-clip-path: polygon(0 12%, 100% 0, 100% 100%, 0 100%);
    --_cs-front-y-rotation: 0deg;
    --_cs-back-y-rotation: 0deg;
    --_card-box-shadow: 0 1.5rem 4rem rgba(0, 0, 0, 0.15);
    --_cs-box-shadow: none;
    --_cta-position: static;
    --_cta-translate: translate(0);
    --_cta-padding: 6rem 0 4rem;
    --_price-box-margin-bottom: 3rem;
  }
}
.card__side {
  height: var(--_cs-height);
  transition: all 0.8s ease;
  position: var(--_cs-position);
  top: 0;
  left: 0;
  backface-visibility: hidden;
  border-radius: 4px;
  overflow: hidden;
  box-shadow: var(--_cs-box-shadow);
  /* `width: 100%;` is needed because elements with `position: absolute` set have their width
  * defined by their content, I think it is `width: max-content;`. */
  width: 100%;
}
.card__side--front {
  background-color: #fff;
}
.card__side--back {
  clip-path: var(--_cs-back-clip-path);
  rotate: y var(--_cs-back-y-rotation);
}
.card__side--back-1 {
  background-image: linear-gradient(to right bottom, #ffb900, #ff7730);
}
.card__side--back-2 {
  background-image: linear-gradient(to right bottom, #7ed56f, #28b485);
}
.card__side--back-3 {
  background-image: linear-gradient(to right bottom, #2998ff, #5643fa);
}
.card:hover .card__side--front, .card:focus-within .card__side--front {
  rotate: y var(--_cs-front-y-rotation);
}
.card:hover .card__side--back, .card:focus-within .card__side--back {
  rotate: y 0deg;
  /* hint: the value of `rotate` (or `transform: rotate()`) is the final position after the rotation,
   * so don't make a mistake and this that this value will be added to the final position after an
   * earlier rotation.
   * 
   * However, this is actually the case when the previous rotation has been performed by its "counter
   * part property", in this scenario the current rotation will start from the final position of the
   * last rotation. Taking the code above as example: 
   * 
   * // if .card__side--back was set like:
   * &--back {
   * color: white;
   * rotate: y 180deg;
   *
   * // then in .card:hover .card__side--back we could just add or remove 180deg to finish the this new
   * // rotation at 0deg:
   * &:hover &__side--back {
   *   transform: rotateY(180deg);
   * }
   */
}
.card__picture {
  height: 23rem;
  background-size: cover;
  background-position: center;
  background-blend-mode: screen;
  clip-path: polygon(0 0, 100% 0, 100% 85%, 0 100%);
}
.card__picture--1 {
  background-image: linear-gradient(to right bottom, #ffb900, #ff7730), url("../img/nat-5.jpg");
}
.card__picture--2 {
  background-image: linear-gradient(to right bottom, #7ed56f, #28b485), url("../img/nat-6.jpg");
}
.card__picture--3 {
  background-image: linear-gradient(to right bottom, #2998ff, #5643fa), url("../img/nat-7.jpg");
}
.card__heading {
  width: 15ch;
  font-size: 2.8rem;
  font-weight: 300;
  text-align: right;
  text-transform: uppercase;
  color: #fff;
  position: absolute;
  top: 12rem;
  right: 2rem;
}
.card__heading-span {
  padding: 1rem 1.5rem;
  /* `box-decoration-break: clone;` makes the breaks of an inline inline element be treated as different
   * boxes and thus applies styles as if each piece had it own box model */
  -webkit-box-decoration-break: clone;
  box-decoration-break: clone;
}
.card__heading-span--1 {
  background-image: linear-gradient(to right bottom, rgba(255, 185, 0, 0.85), rgba(255, 119, 48, 0.85));
}
.card__heading-span--2 {
  background-image: linear-gradient(to right bottom, rgba(126, 213, 111, 0.85), rgba(40, 180, 133, 0.85));
}
.card__heading-span--3 {
  background-image: linear-gradient(to right bottom, rgba(41, 152, 255, 0.85), rgba(86, 67, 250, 0.85));
}
.card__details ul {
  list-style: none;
  margin: 0 auto;
  width: 80%;
}
.card__details ul li {
  text-align: center;
  font-size: 1.5rem;
  padding: 1rem;
}
.card__details ul li:not(:last-child) {
  border-bottom: 1px solid #eee;
}
.card__cta {
  position: var(--_cta-position);
  width: 100%;
  top: 50%;
  left: 50%;
  transform: var(--_cta-translate);
  padding: var(--_cta-padding);
}
.card__price-box {
  transform-style: preserve-3d;
  color: #fff;
  margin-bottom: var(--_price-box-margin-bottom);
}
.card__price-only {
  font-size: 1.4rem;
  text-transform: uppercase;
}
.card__price-value {
  font-size: 6rem;
  font-weight: 300;
}

.story {
  --_story-width: 90%;
  --_story-padding: 6rem;
  --_skewX-value: 12deg;
  width: var(--_story-width);
  margin: 0 auto;
  box-shadow: 0 30px 60px rgba(0, 0, 0, 0.1);
  background-color: rgba(255, 255, 255, 0.6);
  border-radius: 3px;
  padding: var(--_story-padding);
  transform: skewX(calc(var(--_skewX-value) * -1));
}
@media screen and (max-width: 56.25em) {
  .story {
    --_story-width: 100%;
    --_story-padding: 2rem;
  }
}
@media screen and (max-width: 37.5em) {
  .story {
    --_skewX-value: 0deg;
  }
}
.story > * {
  transform: skewX(var(--_skewX-value));
}
.story__shape {
  width: 15rem;
  height: 15rem;
  float: left;
  position: relative;
  overflow: hidden;
  margin-right: 2.5rem;
  border-radius: 50%;
}
@supports (clip-path: polygon(0 0)) or (-webkit-clip-path: polygon(0 0)) {
  .story__shape {
    border-radius: none;
    shape-outside: circle(50%);
    clip-path: circle(50%);
  }
}
.story__img {
  height: 100%;
  transform: translateX(-40px) scale(1.2);
  transition: all 375ms;
}
.story__caption {
  font-size: 1.7rem;
  color: #fff;
  text-transform: uppercase;
  text-align: center;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, 80%);
  opacity: 0;
  transition: all 375ms;
}
.story:hover .story__caption {
  transform: translate(-50%, -50%);
  opacity: 1;
}
.story:hover .story__img {
  transform: translateX(-40px) scale(1);
  filter: blur(3px) brightness(80%);
}

.bg-video {
  position: absolute;
  width: 100%;
  height: 100%;
  opacity: 0.15;
  top: 0;
  left: 0;
  z-index: -1;
}
.bg-video__content {
  /* object-fit property values are: 
   * cover: covers the whole area and maintains the aspect ratio (some content clip may occur).
   * fill: covers the whole area but doesn't maintain the aspect ratio (no content clipping may occur).
   * contain: makes the element always be contained in its parent and maintains the aspect ratio,
   *          i.e. the element is always touching top/bottom or left/right (whichever is smaller),
   *          because it scales up or down as need to fit as a whole in the parent.
   * scale-down: just like `contain` value but the element only scales down, i.e. once it has
   *             reached its original size it won't scale up anymore, even if there is space to.
   * none: keeps the element's original size but makes sure it still fits its parent (i.e. clips
   *       what is overflowing, if needed, and also applies the value of `object-position`)
   *
   * As used bellow, the <video> content will cover 100% of the parent element height and width,
   * and also maintain its original aspect ratio. Width and height does NOT represent the video
   * dimensions, but the area this video must fit in its parent. 
   * 
   * object-fit property ONLY works alongside height and width (generally both 100%), if there
   * is only height or only width, it's like object-fit wasn't being applied and the content may
   * even overflow the parent (which is something that object-fit also solves for you). */
  height: 100%;
  width: 100%;
  object-fit: cover;
}

.form {
  --_radio-group-width: 49%;
  --_radio-group-margin-bottom: 0;
  --_last-form-group-margin-top: 5rem;
  /* while <input> placeholder is being shown, the associated <label> will be invisible
   * an translated upwards, so when it reappears (as the placeholder goes away), it will
   * be back to its original position in an animation as if the placeholder itself is
   * going down. */
}
@media screen and (max-width: 56.25em) {
  .form {
    --_radio-group-width: 100%;
    --_radio-group-margin-bottom: 2rem;
    --_last-form-group-margin-top: 0rem;
  }
}
.form__group:not(:last-child) {
  margin-bottom: 2rem;
}
.form__group:last-child {
  margin-top: var(--_last-form-group-margin-top);
}
.form__input {
  font-size: 1.5rem;
  /* <input> elements DON'T INHERIT the font properties, so it need to define it or
   * set it to inherit it's parent font-family value (this will also be used by the
   * form's placeholder text) */
  font-family: inherit;
  color: inherit;
  /* in form inputs horizontal padding tends to look smaller, so make it a bit
   * bigger to compensate for that and make it look better*/
  padding: 1.5rem 2rem;
  border-radius: 3px;
  background-color: rgba(255, 255, 255, 0.5);
  border-style: none;
  width: 100%;
  display: block;
  /* this transparent border is here just so that when we add a greenish border
   * as the user focuses on this <input> the elements below aren't moved around,
   * and that is because the border is already here but not showing yet. */
  border-bottom: 3px solid transparent;
  transition: border-bottom 0.2s;
  /* via the ::placeholder pseudo-element you can add rule sets specific to an
   * <input> placeholder, e.g. a different font color, a lighter one maybe. */
}
.form__input:focus {
  outline: none;
  box-shadow: 0 16px 20px rgba(0, 0, 0, 0.1);
  border-bottom: 3px solid #55c57a;
}
.form__input:focus:invalid {
  border-bottom: 3px solid #ff7730;
}
.form__input::placeholder {
  color: #999;
}
.form__label {
  font-size: 1.4rem;
  font-weight: 700;
  margin-left: 2rem;
  margin-top: 0.7rem;
  display: inline-block;
  opacity: 1;
  transition-property: transform opacity;
  transition-duration: 0.2s;
}
.form__input:placeholder-shown + .form__label {
  transform: translateY(-4.3rem);
  opacity: 0;
  visibility: hidden;
}
.form__radio-group {
  /* as we know there are only 2 radio buttons, `width: 49%;` + `display: inline-block;`
   * will make sure these are side by side in the layout. */
  width: var(--_radio-group-width);
  margin-bottom: var(--_radio-group-margin-bottom);
  display: inline-block;
}
.form__radio-input {
  /* so the actual <input type="radio"> which cannot be styled is removed from the layout
   * and also don't show on screen. It doesn't affect is functionality, by clicking the
   * <label> linked to this input, it will still be selected. */
  display: none;
}
.form__radio-label {
  cursor: pointer;
}
.form__radio-button {
  display: inline-block;
  vertical-align: middle;
  transform: translateY(-2px);
  height: 1.1rem;
  width: 1.1rem;
  border-radius: 50%;
  /* as there is no way (that I know of) to offset a border, I'll make the outer circle
   * of this radio button out of the outline property, which can be offset. As outline
   * doesn't take actual space in the page structure, i'm making up for that with a margin
   * that is the sum of the outline-width and outline-offset. */
  outline: 0.2rem solid #ff7730;
  /* if you're really going to use `outline-offset` on your project, it may be worth to
   * look for more details on the behavior of Google Chrome of not accepting non-whole 
   * pixel values for this property (I think it rounded these broken numbers down). */
  outline-offset: 0.3rem;
  margin: 0.5rem;
  /* In the Udemy css course, the instructor achieves the same using the border property
   * to represent the outer circle and makes the inner circle out of the border of the
   * ::after pseudo-element which is centered using `position: absolute`. I just found
   * my approach easier and simpler. In this case, the background-color will be animated
   * which is far from ideal, but it's an area so small that there show be unnoticeable
   * performance wise. */
  transition: background-color 0.2s;
}
.form__radio-input:checked + .form__radio-label .form__radio-button {
  background-color: #ff7730;
}

.popup {
  --_content-width: 75%;
  --_right-container-padding: 3rem 5rem;
  --_text-col-count: 2;
  --_close-btn-top: 2rem;
  --_close-btn-right: 2rem;
  position: fixed;
  top: 0;
  left: 0;
  /* Regarding width, it seems better to use 100% instead of 100vw (when it's possible) because,
   * the `vw` unit takes into account the scroll bar width too, i.e. the whole window width.
   * Meanwhile, 100% in most cases will represent 100% of the available space, i.e. disregards
   * the scrollbar width. */
  width: 100%;
  height: 100%;
  padding: 4rem;
  background-color: rgba(0, 0, 0, 0.8);
  z-index: 1004;
  opacity: 0;
  visibility: hidden;
  perspective: 7rem;
  transition: opacity 0.3s;
  /* The :target pseudo-class represents the state when this class (.popup in this case) is present
   * in the url as a fragment, e.g. 'yoursite.com/#popup', that is when the styles defined here will
   * be applied to the class itself. */
}
@media screen and (max-width: 56.25em) {
  .popup {
    --_content-width: 90%;
    --_text-col-count: 1;
    --_right-container-padding: 3rem 2rem;
  }
}
@media screen and (max-width: 37.5em) {
  .popup {
    --_close-btn-top: -0.8rem;
    --_close-btn-right: -0.8rem;
  }
}
@supports (backdrop-filter: blur(10px)) or (-webkit-backdrop-filter: blur(10px)) {
  .popup {
    -webkit-backdrop-filter: blur(10px);
    backdrop-filter: blur(10px);
    background-color: rgba(0, 0, 0, 0.3);
  }
}
.popup:target {
  opacity: 1;
  visibility: visible;
}
.popup__content {
  position: absolute;
  top: 50%;
  left: 50%;
  translate: -50% -50%;
  height: 50rem;
  width: var(--_content-width);
  max-width: 114rem;
  max-height: 85%;
  background-color: #fff;
  box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
  border-radius: 3px;
  transform: translateZ(-100px);
  transition: transform 0.4s 150ms;
}
.popup:target .popup__content {
  transform: translateZ(0px);
}
.popup__left {
  display: inline-block;
  width: 33.3333333%;
  height: 100%;
  overflow: clip;
  border-radius: 3px 0 0 3px;
}
.popup__right {
  display: inline-block;
  width: 66.6666667%;
  max-height: 100%;
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  right: 0;
  overflow: auto;
  padding: var(--_right-container-padding);
}
.popup__img {
  /* `vertical-align: middle` removes void space bellow the image, as <img> is an inline element,
   * that is referent to the line-height set up. */
  vertical-align: middle;
  height: 50%;
  width: 100%;
  object-fit: cover;
}
.popup__text {
  font-size: 1.4rem;
  margin-bottom: 4rem;
  text-align: justify;
  column-count: var(--_text-col-count);
  column-gap: 3rem;
  column-rule: 2px solid #eee;
}
.popup__close {
  position: absolute;
  top: var(--_close-btn-top);
  right: var(--_close-btn-right);
  z-index: 1005;
}

.navigation {
  --_button-top: 6rem;
  --_button-right: 6rem;
  --_bg-scale-value: 90;
  /* To make it all much more scalable, simpler to use and maintainable, its a pretty
   * good idea to use css custom properties to change base values in many places at the
   * same time, and based on that, in lots of cases, within media queries it's so much
   * easier to just change these custom properties values instead of creating a media
   * query within each selector and describing multiple css properties which in the end
   * have a single base value as reference. In the usage below, it is actually changing
   * the `top` and `right` properties of both `&__button` and also `&__background` (in
   * a single media query with just 2 lines! it's less then half we'd have to write if
   * were doing it according to isolate selectors or properties).
   *
   * THIS SIMPLY CANNOT BE DONE WITH SASS VARIABLES because these don't exist in the
   * final compiled css, thus the will be nothing to be dynamically changed there. */
}
@media screen and (max-width: 56.25em) {
  .navigation {
    --_button-top: 2.5rem;
    --_button-right: 3.5rem;
    --_bg-scale-value: 53;
  }
}
@media screen and (max-width: 37.5em) {
  .navigation {
    --_bg-scale-value: 40;
  }
}
.navigation__checkbox {
  display: none;
}
.navigation__button {
  height: 7rem;
  width: 7rem;
  border-radius: 50%;
  position: fixed;
  z-index: 1002;
  top: var(--_button-top);
  right: var(--_button-right);
  line-height: 7rem;
  background-color: #fff;
  cursor: pointer;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
}
.navigation__background {
  height: 6rem;
  width: 6rem;
  border-radius: 50%;
  position: fixed;
  z-index: 1000;
  top: calc(var(--_button-top) + 0.5rem);
  right: calc(var(--_button-right) + 0.5rem);
  /* While `linear-gradient` goes from side to side, the `radial-gradient` starts at the center
   * and expands outwards. first you define the color in the center and after the outer color */
  background-image: radial-gradient(#7ed56f, #28b485);
  transition: transform 0.8s cubic-bezier(0.83, 0, 0.17, 1);
}
.navigation__nav {
  height: 100vh;
  width: 100vw;
  position: fixed;
  z-index: 1001;
  top: 0;
  left: 0;
  opacity: 0;
  visibility: hidden;
  transform: translateX(-500px);
  transition: opacity 0.4s cubic-bezier(0.46, 0, 0.36, 0), transform 0.4s cubic-bezier(0.68, -0.6, 0.32, 1.6);
  transition-delay: 0.2s;
}
.navigation__list {
  list-style: none;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  text-align: center;
  width: max-content;
}
.navigation__item {
  margin: 1rem;
}
.navigation__link {
  display: inline-block;
  font-size: 3rem;
  font-weight: 300;
  padding: 1rem 2rem;
  color: #fff;
  text-decoration: none;
  text-transform: uppercase;
  background-image: linear-gradient(120deg, transparent 0%, transparent 50%, #fff 50%);
  background-size: 225%;
  transition: all 0.3s;
}
.navigation__link span {
  margin-right: 1.5rem;
}
.navigation__link:hover, .navigation__link:active, .navigation__link:focus {
  /* when a percentage is used like that (bellow), the background X coordinate goes to the percentage
   * with a Y coordinate set to 50%. So in the end, the thick is: expand the "solid part" of the
   * background until it disappears (as done above) and then, on hover, focus and active, bring the
   * background-position to 100% so the solid part of it reappears. */
  background-position: 100%;
  color: #55c57a;
  transform: translateX(1rem);
}
.navigation__checkbox:checked ~ .navigation__background {
  transform: scale(var(--_bg-scale-value));
}
.navigation__checkbox:checked ~ .navigation__nav {
  opacity: 1;
  visibility: visible;
  transform: translate(0);
}
.navigation__icon {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
.navigation__icon, .navigation__icon::before, .navigation__icon::after {
  width: 3rem;
  height: 2px;
  background-color: #333;
  display: inline-block;
}
.navigation__icon::before, .navigation__icon::after {
  content: "";
  position: absolute;
  transition-property: translate, rotate, opacity;
  transition-duration: 200ms;
  transition-timing-function: ease-in-out;
}
.navigation__icon::before {
  top: -0.8rem;
}
.navigation__icon::after {
  top: 0.8rem;
}
.navigation__button:hover .navigation__icon::before {
  translate: 0 -0.2rem;
}
.navigation__button:hover .navigation__icon::after {
  translate: 0 0.2rem;
}
.navigation__checkbox:checked + .navigation__button .navigation__icon {
  /* so the actual <span> element "disappears", ::before and ::after are not affected,
   * if we'd use `opacity instead, everything would disappear `*/
  background-color: transparent;
}
.navigation__checkbox:checked + .navigation__button .navigation__icon::before {
  rotate: -45deg;
  translate: 0 0.8rem;
}
.navigation__checkbox:checked + .navigation__button .navigation__icon::after {
  rotate: 45deg;
  translate: 0 -0.8rem;
}

.header {
  --_bg-hero-image: url("../img/hero-small.jpg");
  /* the way to implement responsive images in css is to use media queries that will what min/max-width
   * and/or min/max-resolution (set in dpi - 2x displays have about 192dpi) */
  /* the calc is to make it fits the viewport with 30px of padding above and bellow (added in <body>) */
  height: calc(98vh - (60px - 2vh)); /* 98% of the viewport height (60px is for 2 * <body> padding (30px)) */
  /* always apply a gradient on the background via the `background-image` css prop, and if its the case
   * define the actual bg image afterwards, this way the gradient will be on top of the image - make sure
   * to correctly adjust the gradient opacity */
  background-image: linear-gradient(to right bottom, rgba(126, 213, 111, 0.8), rgba(40, 180, 133, 0.8)), var(--_bg-hero-image);
  background-size: cover; /* directly on replaced elements, e.g. <img>, <video>, you can use `object-fit` */
  background-position: top; /* tells which part of the bg should be "fixed" and will never go out of the frame */
  /* position: relative; is like `static` but respects reference values from `top`, `left`, `bottom` and `right`,
   * and also can be used as "anchor" to child elements which have `position: absolute` */
  position: relative;
}
@media screen and (min-resolution: 192dpi) and (min-width: 37.5em), screen and (-webkit-device-pixel-ratio: 2) and (min-width: 37.5em), screen and (min-width: 75em) {
  .header {
    --_bg-hero-image: url("../img/hero.jpg");
  }
}
@supports (clip-path: polygon(0 0)) or (-webkit-clip-path: polygon(0 0)) {
  .header {
    /* clip-path apply a "mask" in the object, you define the coordinate based on what you want to be shown on
     * screen - the `polygon` function receives coordinates to create as polygon shaped mask.
     * Fortunately, coordinates can be dynamic and passed as percentages */
    -webkit-clip-path: polygon(0 0, 100% 0, 100% 85vh, 0 100%);
    clip-path: polygon(0 0, 100% 0, 100% 85vh, 0 100%);
  }
}
.header__logo-box {
  position: absolute;
  top: 4rem; /* relative to it's closest positioned parent, `.header` in this case */
  left: 4rem; /* relative to it's closest positioned parent, `.header` in this case */
}
.header__logo {
  height: 3.5rem; /* by just setting `height` and omitting the `width`, this prop will be automatically figured out */
}
.header__text-box {
  /* When you want to symmetrically center an element, just use flexbox prop on parents and child elements, but when
   * it's not gonna be 100% symmetrical, that's how you do it: */
  position: absolute; /* now it's positioned relative to it's closest positioned parent */
  top: 40%; /* relative to `.header` */
  left: 50%; /* relative to `.header` */
  /* as the element is positioned based on its top left corner, the prop bellow "makes it" be positioned based on
   * the element's center. Relative to the element's own position, it repositions it 50% (of its length) to the left
   * and 50% (of its height) to the top */
  transform: translate(-50%, -50%);
  text-align: center; /* this will make sure `.btn` element is centered */
}

/* Even though floats are not used anymore, it may be interesting to still know how these
 * work in case you have to update an old website that uses it to newer technologies */
.row {
  display: flow-root;
  max-width: 114rem;
  margin: 0 auto;
  /* I don't want this padding to change according to root font-size because in case its a bigger
   * font-size this padding would also become bigger and thus squash letters even more. */
  padding: 0 16px;
  /* [class^="col-"] selects all elements whose class attribute value starts with "col-"
   * actually is the `^` symbol that does this trick.
   * `^` --> starts with the declared value
   * `*` --> contains the declared value
   * `$` --> ends with the declared value */
}
.row:not(:last-child) {
  margin-bottom: 8rem;
}
@media screen and (max-width: 56.25em) {
  .row:not(:last-child) {
    margin-bottom: 6rem;
  }
}
@media screen and (max-width: 56.25em) {
  .row {
    max-width: 55rem;
  }
}
.row [class^=col-] {
  float: left;
}
.row [class^=col-]:not(:last-child) {
  margin-right: 6rem;
}
@media screen and (max-width: 56.25em) {
  .row [class^=col-]:not(:last-child) {
    margin-right: 0;
    margin-bottom: 6rem;
  }
}
@media screen and (max-width: 56.25em) {
  .row [class^=col-] {
    /* All columns will spread the whole width in tab-port layouts. !important is being used
     * just so that this style gets applied no matter the order or specificity. */
    width: 100% !important;
  }
}
.row .col-1-of-2 {
  /* no need to use # + { <var-here> } within `calc()` in dart-sass@1.72.0 */
  width: calc(calc(100% - 6rem)/2 * 1 + 0rem);
}
.row .col-1-of-3 {
  width: calc(calc(100% - 12rem)/3 * 1 + 0rem);
}
.row .col-2-of-3 {
  width: calc(calc(100% - 12rem)/3 * 2 + 6rem);
}
.row .col-1-of-4 {
  width: calc(calc(100% - 18rem)/4 * 1 + 0rem);
}
.row .col-2-of-4 {
  width: calc(calc(100% - 18rem)/4 * 2 + 6rem);
}
.row .col-3-of-4 {
  width: calc(calc(100% - 18rem)/4 * 3 + 12rem);
}

.footer {
  --_footer-padding-block: 10rem;
  --_lb-margin-bottom: 8rem;
  --_cp-width: 80%;
  --_cp-margin-left: auto;
  background-color: #333;
  padding: var(--_footer-padding-block) 0;
  font-size: 1.4rem;
  color: #f7f7f7;
}
@media screen and (max-width: 56.25em) {
  .footer {
    --_footer-padding-block: 8rem;
    --_lb-margin-bottom: 6rem;
    --_cp-width: 100%;
    --_cp-margin-left: 0;
  }
}
.footer__logo-box {
  text-align: center;
  margin-bottom: var(--_lb-margin-bottom);
}
.footer__logo {
  width: 15rem;
}
.footer__navigation {
  border-top: 1px solid #777;
  padding-top: 2rem;
}
.footer__list {
  list-style: none;
  text-align: center;
}
.footer__item {
  display: inline-block;
}
.footer__item:not(:last-child) {
  margin-right: 2rem;
}
.footer__link {
  background-color: #333;
  text-decoration: none;
  text-transform: uppercase;
  color: inherit;
  display: inline-block;
  transition: transform 150ms;
}
.footer__link:hover, .footer__link:active, .footer__link:focus {
  color: #55c57a;
  box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4);
  transform: rotate(5deg) scale(1.3);
}
.footer__copyright {
  padding-top: 2rem;
  border-top: 1px solid #777;
  width: var(--_cp-width);
  margin-left: var(--_cp-margin-left);
}

/* in scss files within the pages folder (like this file), we can put style that could
 * be in the components folder but actually are going to appear only in this specific page */
.section-about {
  --_padding-top: 8rem;
  --_padding-bottom: 20vh;
  background-color: #f7f7f7;
  /* 8rem is the padding we want and +$margin-negative-indentation is to "cancel out" the
   * negative margin-top property set just bellow. In the end we're just doing that so the
   * background color of this element "flows" behind the element above this one.
   * (I looks like a hack to me, maybe there is a better way to do that...) */
  padding: calc(var(--_padding-top) + 20vh) 0 var(--_padding-bottom);
  /* when you use negative values for margin instead of "expanding" outwards and pushing elements
   * around, it "expands" inwards and this way its box model gets smaller, thus the element gets
   * closer to other elements */
  margin-top: -20vh;
}
@media screen and (max-width: 56.25em) {
  .section-about {
    --_padding-top: 3rem;
    --_padding-bottom: 9vh;
  }
}

.section-features {
  --_padding-block: 15rem;
  padding: var(--_padding-block) 0;
  background-image: linear-gradient(to right bottom, rgba(126, 213, 111, 0.8), rgba(40, 180, 133, 0.8)), url("../img/nat-4.jpg");
  background-size: cover;
  margin-top: -12rem;
  transform: skewY(-7deg);
}
@media screen and (max-width: 56.25em) {
  .section-features {
    --_padding-block: 10rem;
  }
}
.section-features > * {
  transform: skewY(7deg);
}

.section-tours {
  --_padding-block: 8rem;
  padding: 20rem 0 8rem;
  background-color: #f7f7f7;
  margin-top: -12rem;
}

.section-stories {
  --_padding-block: 15rem;
  position: relative;
  padding: var(--_padding-block) 0;
}
@media screen and (max-width: 56.25em) {
  .section-stories {
    --_padding-block: 6rem;
  }
}

.section-book {
  --_padding-block: 15rem;
  padding: var(--_padding-block) 0;
  background-image: linear-gradient(to right bottom, #7ed56f, #28b485);
}
@media screen and (max-width: 56.25em) {
  .section-book {
    --_padding-block: 8rem;
  }
}

.book {
  --_form-width: 50%;
  --_form-padding: 6rem;
  /* regarding `linear-gradient()` its direction can be set in degrees also, and you can define a percentages
   * referring after the color which will represent where it begins or ends, e.g. below the a gradient that
   * starts at 0% in white and goes up to 50%, and from there up to the end it its transparent so the actual
   * background image can show. */
  background-image: linear-gradient(105deg, rgba(255, 255, 255, 0.75) 0%, rgba(255, 255, 255, 0.75) var(--_form-width), transparent var(--_form-width)), url("../img/nat-10.jpg");
  background-size: cover;
  background-position: right;
  border-radius: 4px;
  box-shadow: 0 15px 40px rgba(0, 0, 0, 0.2);
}
@media screen and (max-width: 75em) {
  .book {
    --_form-width: 65%;
  }
}
@media screen and (max-width: 56.25em) {
  .book {
    --_form-width: 100%;
    --_form-padding: 2rem;
  }
}
.book__form {
  width: var(--_form-width);
  padding: var(--_form-padding);
  padding-bottom: 4rem;
}

/*# sourceMappingURL=style.css.map */
