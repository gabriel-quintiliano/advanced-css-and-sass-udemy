/* in thw "7-1 architecture" this main.scss file only serves to import other files 
@import "folder/file"; --> will import `folder/_file.scss` */
/* this file as the name suggests will be the base the styles will be build on top of. In here
 * you will set global resets, styles and normalizations */
/* basic "global" reset - affects all html elements including before and after pseudo-elements */
*,
*::after,
*::before {
  margin: 0;
  padding: 0;
  /* every element will inherit its box-sizing from its parent, which in this case will be the value
   * `box-sizing: border-box` set in <body>. Doing it this way (via inheritance) is considered a slightly
   * better approach than just setting it via the universal selector (I just dunno why) */
  box-sizing: inherit; }

html {
  font-size: 62.5%;
  /* 62.5% * 16px (which is generally browser font-size) = 10 px, thus 1rem = 10px */
  /* rem is not supported bellow IE 9 */ }

body {
  /* everything related to "global" fonts should be done in the body tag selector, because
   * this way every element within <body> will inherit these style and its also more efficient
   * that doing the same via the `*` selector, which selects each element "individually", here
   * we're using the power of inheritance */
  box-sizing: border-box;
  /* margins and paddings are NOT added to the total size of the element */ }

/* in this file you should put all animations that'll be used in the project */
/* regarding browser performance, it's better to only ever animate the `opacity` and `transform` properties
 * because these only trigger the `composite` phase of rendering the element on screen, the other phases,
 * `style`, `layout` (of elements) and `paint` are skipped.
 *
 * of course you can animate other properties, but remember that browser animations are only optimized for
 * `opacity` and `transform`. This video `https://www.youtube.com/watch?v=N5EW4HnF6FU` demonstrates this in
 * practice.
 *
 * for example when you deal with an element's width or margin you're also messing with the positioning of
 * the elements next to it and because of that, animations with those become less performant and look bad. */
@keyframes moveInLeft {
  0% {
    opacity: 0;
    /* translateX repositions the element on the x axis relative to its initial position */
    transform: translateX(-10rem);
    /* the animation starts with the elem. 10rem (100px) to the left */ }
  80% {
    transform: translateX(1rem); }
  100% {
    opacity: 1;
    transform: translateX(0);
    /* so the elem. is in its final position in the end of the animation */ } }

@keyframes moveInRight {
  0% {
    opacity: 0;
    transform: translateX(10rem);
    /* the animation starts with the elem. 10rem (100px) to the right */ }
  80% {
    transform: translateX(-1rem); }
  100% {
    opacity: 1;
    transform: translateX(0);
    /* so the elem. is in its final position in the end of the animation */ } }

@keyframes moveInBottom {
  0% {
    opacity: 0;
    transform: translateY(3rem);
    /* the animation starts with the elem. 100px to the right */ }
  100% {
    opacity: 1;
    transform: translateY(0);
    /* so the elem. is in its final position in the end of the animation */ } }

/* in this file you should put styles related to the general typography of the website */
body {
  font-family: "Lato", sans-serif;
  /* Use "Lato" font-family if available, otherwise use "sans-serif" */
  font-weight: 400;
  font-size: 1.6rem;
  line-height: 1.7;
  /* now line-height will be 1.7x bigger than the pre-defined line-height*/
  color: #777;
  /* sets text color */
  padding: 3rem;
  /* this padding will not be inherited by elements within <body> */ }

.heading-primary {
  color: #fff;
  text-transform: uppercase;
  /* maybe this is needed if animations (of child elements of this) flick, this prop somehow fixes it */
  backface-visibility: hidden;
  margin-bottom: 6rem; }
  .heading-primary--main {
    display: block;
    font-size: 6rem;
    font-weight: 400;
    letter-spacing: 3.5rem;
    animation-name: moveInLeft;
    animation-duration: 1.3s;
    animation-timing-function: ease-out;
    /*
    animation-delay: 3s; - delay for the animation to start
    animation-iteration-count: 3; - how many times should the animation be repeated
    */ }
  .heading-primary--sub {
    display: block;
    font-size: 2rem;
    font-weight: 700;
    letter-spacing: 1.75rem;
    animation: moveInRight 1.3s ease-out;
    /* this is the shortcut for everything described bellow */
    /* animation-name: moveInRight;
    animation-duration: 1.3s;
    animation-timing-function: ease-out; */ }

.heading-secondary {
  display: inline-block;
  font-size: 3.5rem;
  text-transform: uppercase;
  font-weight: 700;
  background-image: linear-gradient(to right, #7ed56f, #28b485);
  /* by default the `background`(shortcut), `background-color` and `background-images` properties fill
   * the whole border-box, but via the `background-clip` property you can change this behavior to:
   * `padding-box`, `content-box` or `text`, so that the background you fill only this specific area. */
  background-clip: text;
  color: transparent;
  letter-spacing: 2px;
  transition: all .2s; }
  .heading-secondary:hover {
    transform: skewY(2deg) skewX(15deg) scale(1.1);
    text-shadow: 0.5rem 1rem 2rem rgba(0, 0, 0, 0.2); }

.heading-tertiary {
  font-weight: 700;
  text-transform: uppercase; }

.paragraph:not(:last-child) {
  margin-bottom: 3rem; }

/* in this file you'll have utility classes which are generic classes that have a single
 * or simple style declaration that can be reused throughout the project */
.u-center-text {
  text-align: center; }

.u-margin-bottom-extra-small {
  margin-bottom: 1rem; }

.u-margin-bottom-small {
  margin-bottom: 2rem; }

.u-margin-bottom-medium {
  margin-bottom: 4rem; }

.u-margin-bottom-big {
  margin-bottom: 8rem; }

.u-margin-top-extra-small {
  margin-top: 1rem; }

.u-margin-top-small {
  margin-top: 2rem; }

.u-margin-top-medium {
  margin-top: 4rem; }

.u-margin-top-big {
  margin-top: 8rem; }

.u-padding-left-small {
  padding-left: 1rem; }

.u-pos-relative {
  position: relative; }

.u-pos-absolute {
  position: absolute; }

.btn {
  /* :link pseudo-class represents an anchor that has a destination set i.e. href */
  /* :active pseudo-class represents an anchor tag that is being clicked (left button of mouse pressed) */
  /* ::after is a pseudo-element, which are virtual elements that are inserted as child-elements from the
   * real html element, these will only appear on screen if they have `display` or `content` set, and you
   * also need to define its `height` and `width` (remember, as these are within the real html element,
   * the 100% value refers to the whole size of this element)
   *  */ }
  .btn:link, .btn:visited {
    text-transform: uppercase;
    text-decoration: none;
    /* gets rid of that default underline in anchor tags text content */
    padding: 1.5rem 4rem;
    /* by setting `display: inline-block` the inner-display prop = `inline` and because of that you can treat
     * this element as text (so it can be easily centered if its parent element has `text-align: center` set).
     * the `inline-block` value is necessary so there is a box model for us to deal with margins and paddings... */
    display: inline-block;
    border-radius: .7rem;
    /* the `transition` property is a short-hand that will deal with the changing of style of an element,
     * so in the end it can be seen as another way to approach animations.
     * `transition` must always be set alongside the initial state styles.
     *
     * 1. define which css properties this transition will be applied to (if you don't know, use `all`)
     * 2. define the time this style transition will take (from initial state - define above - to final state
     *    which is in this case defined in `.btn:hover` and `.btn:active`) */
    transition: all .2s;
    position: relative; }
  .btn:hover, .btn:focus {
    transform: translateY(-3px);
    box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.2);
    /* value = x-axis y-axis blur color */
    /* ::after pseudo-element when hovered */ }
    .btn:hover::after, .btn:focus::after {
      transform: scaleX(1.4) scaleY(1.6);
      /* scales this pseudo-element to twice its size */
      opacity: 0; }
  .btn:active {
    transform: translateY(-1px);
    box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.2);
    /* value = x-axis y-axis blur color */ }
  .btn--white {
    background-color: #fff;
    color: #777; }
    .btn--white::after {
      background-color: #fff; }
  .btn--green {
    background-color: #55c57a;
    color: #fff; }
    .btn--green::after {
      background-color: #55c57a; }
  .btn::after {
    content: "";
    /* it just need to have `content` set, it can even be empty */
    display: inline-block;
    height: 100%;
    /* refers to 100% of the `.btn` element */
    width: 100%;
    /* refers to 100% of the `.btn` element */
    border-radius: 7px;
    /* used px because I don't want it to change based on browser font-size */
    position: absolute;
    /* this prop + `top: 0;` and `left: 0;` positions this pseudo-elem right over `.btn` */
    top: 0;
    left: 0;
    transition: all .4s;
    z-index: -1;
    /* so it hinds behind `.btn` */ }
  .btn--white::after {
    background-color: #fff; }
  .btn--animated {
    /* animation: <animation-name> <animation-duration> <animation-timing-function> <animation-delay> */
    animation: moveInBottom 0.65s ease-out .75s;
    /* `backwards` value already applies styles define in the first `@keyframes` animation rules (0% in this
     * case), during `animation-delay` (.75s in this case). */
    animation-fill-mode: backwards; }

.btn-text:link, .btn-text:visited {
  color: #55c57a;
  display: inline-block;
  text-decoration: none;
  border-bottom: 1px solid #55c57a;
  padding: 3px;
  border-radius: 5px;
  transition: all .3s ease-out; }

.btn-text:hover, .btn-text:focus {
  background-color: #55c57a;
  color: #fff;
  box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.15);
  transform: translateY(-2px); }

.btn-text:active {
  box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
  transform: translateY(0px); }

.composition {
  position: relative;
  perspective: 55rem;
  perspective-origin: 30% 0%;
  /* when .component is being hovered (i.e. when any element within .component container is being hovered),
   * selects all descendants from .component which are NOT being hovered at that moment.
   * final selector --> .component:hover .component__photo:not(:hover) */ }
  .composition__photo {
    width: 80%;
    box-shadow: 0 1.5rem 4rem rgba(0, 0, 0, 0.4);
    border-radius: 5px;
    position: absolute;
    transition: all .2s;
    outline-offset: .8rem; }
    .composition__photo--p1 {
      left: -5rem;
      transform: rotateX(80deg) rotateZ(15deg) rotateY(-5deg) scale(0.8);
      translate: 0px 0px -350px; }
    .composition__photo--p2 {
      top: 2rem;
      left: 5rem;
      transform: rotateX(80deg) rotateZ(360deg) rotateY(-5deg) scale(0.9);
      translate: 10rem 0px -200px; }
    .composition__photo--p3 {
      top: 8rem;
      left: 10%;
      transform: rotateX(76deg) rotateZ(20deg) rotateY(352deg); }
    .composition__photo:hover {
      outline: 0.8rem solid #55c57a;
      transform: scale(1);
      translate: 0px 0px 0px;
      z-index: 1; }
  .composition:hover .composition__photo:not(:hover) {
    opacity: 0.7;
    scale: .9; }

.feature-box {
  background-color: #d6e8da;
  padding: 2.5rem;
  text-align: center;
  border-radius: 3px;
  box-shadow: 0 1.5rem 4rem rgba(0, 0, 0, 0.15);
  transition-property: transform box-shadow;
  transition-duration: .2s;
  min-height: 38rem; }
  .feature-box__icon {
    font-size: 6rem;
    margin-bottom: .5rem;
    background-image: linear-gradient(to right, #7ed56f, #28b485);
    background-clip: text;
    color: transparent; }
  .feature-box:hover {
    transform: scale(1.05) translateY(-1.5rem);
    box-shadow: 0 1.5rem 4rem rgba(0, 0, 0, 0.35); }

.card {
  perspective: 150rem;
  position: relative;
  height: 50rem;
  /* Why was it necessary to set a height above?
  *
  * It was necessary because all the child elements of div.card have `position: absolute` set
  * which makes them be removed from the `normal flow` (because of the creation of a new BFC),
  * thus the div.card element collapses (and becomes flat with with no height). Meanwhile, the
  * work around for this situations is setting a height manually (if needed).
  *
  * In this case, the best thing to do was to manually set the height to the same as the content
  * (div.card__side) mainly to use the :hover pseudo-class on that and avoid flickering of the
  * animation applied. */
  /* by hovering .card we rotate the child .card__side and this way we avoid animation flicker,
   * also, the :focus-within pseudo-class will turn the card when tab navigation focus on the
   * button placed on the back side of the card. */
  /* It was best not to nest it above because &__heading-span is an element itself and BEM methodology is
   * against the nesting of different elements, you can only nest those within blocks and within elements
   * you only nest modifiers */ }
  .card__side {
    height: 50rem;
    transition: all .8s ease;
    position: absolute;
    top: 0;
    left: 0;
    backface-visibility: hidden;
    border-radius: 4px;
    overflow: hidden;
    box-shadow: 0 1.5rem 4rem rgba(0, 0, 0, 0.15);
    /* `width: 100%;` is needed because elements with `position: absolute` set have their width
    * defined by their content, I think it is `width: max-content;`. */
    width: 100%; }
    .card__side--front {
      background-color: #fff; }
    .card__side--back {
      rotate: y 180deg; }
      .card__side--back-1 {
        background-image: linear-gradient(to right bottom, #ffb900, #ff7730); }
      .card__side--back-2 {
        background-image: linear-gradient(to right bottom, #7ed56f, #28b485); }
      .card__side--back-3 {
        background-image: linear-gradient(to right bottom, #2998ff, #5643fa); }
  .card:hover .card__side--front,
  .card:focus-within .card__side--front {
    rotate: y -180deg; }
  .card:hover .card__side--back,
  .card:focus-within .card__side--back {
    rotate: y 0deg;
    /* hint: the value of `rotate` (or `transform: rotate()`) is the final position after the rotation,
     * so don't make a mistake and this that this value will be added to the final position after an
     * earlier rotation.
     * 
     * However, this is actually the case when the previous rotation has been performed by its "counter
     * part property", in this scenario the current rotation will start from the final position of the
     * last rotation. Taking the code above as example: 
     * 
     * // if .card__side--back was set like:
     * &--back {
     * color: white;
     * rotate: y 180deg;
     *
     * // then in .card:hover .card__side--back we could just add or remove 180deg to finish the this new
     * // rotation at 0deg:
     * &:hover &__side--back {
     *   transform: rotateY(180deg);
     * }
     */ }
  .card__picture {
    height: 23rem;
    background-size: cover;
    background-position: center;
    background-blend-mode: screen;
    clip-path: polygon(0 0, 100% 0, 100% 85%, 0 100%); }
    .card__picture--1 {
      background-image: linear-gradient(to right bottom, #ffb900, #ff7730), url("../img/nat-5.jpg"); }
    .card__picture--2 {
      background-image: linear-gradient(to right bottom, #7ed56f, #28b485), url("../img/nat-6.jpg"); }
    .card__picture--3 {
      background-image: linear-gradient(to right bottom, #2998ff, #5643fa), url("../img/nat-7.jpg"); }
  .card__heading {
    width: 15ch;
    font-size: 2.8rem;
    font-weight: 300;
    text-align: right;
    text-transform: uppercase;
    color: #fff;
    position: absolute;
    top: 12rem;
    right: 2rem; }
  .card__heading-span {
    padding: 1rem 1.5rem;
    /* `box-decoration-break: clone;` makes the breaks of an inline inline element be treated as different
     * boxes and thus applies styles as if each piece had it own box model */
    -webkit-box-decoration-break: clone;
    box-decoration-break: clone; }
    .card__heading-span--1 {
      background-image: linear-gradient(to right bottom, rgba(255, 185, 0, 0.85), rgba(255, 119, 48, 0.85)); }
    .card__heading-span--2 {
      background-image: linear-gradient(to right bottom, rgba(126, 213, 111, 0.85), rgba(40, 180, 133, 0.85)); }
    .card__heading-span--3 {
      background-image: linear-gradient(to right bottom, rgba(41, 152, 255, 0.85), rgba(86, 67, 250, 0.85)); }
  .card__details ul {
    list-style: none;
    margin: 0 auto;
    width: 80%; }
    .card__details ul li {
      text-align: center;
      font-size: 1.5rem;
      padding: 1rem; }
      .card__details ul li:not(:last-child) {
        border-bottom: 1px solid #eee; }
  .card__cta {
    position: absolute;
    width: 100%;
    top: 50%;
    left: 50%;
    transform: translateX(-50%) translateY(-50%); }
  .card__price-box {
    transform-style: preserve-3d;
    color: #fff;
    margin-bottom: 8rem; }
  .card__price-only {
    font-size: 1.4rem;
    text-transform: uppercase; }
  .card__price-value {
    font-size: 6rem;
    font-weight: 300; }

.header {
  /* the calc is to make it fits the viewport with 30px of padding above and bellow (added in <body>) */
  height: calc(98vh - (60px - 2vh));
  /* 98% of the viewport height (60px is for 2 * <body> padding (30px)) */
  /* always apply a gradient on the background via the `background-image` css prop, and if its the case
   * define the actual bg image afterwards, this way the gradient will be on top of the image - make sure
   * to correctly adjust the gradient opacity */
  background-image: linear-gradient(to right bottom, rgba(126, 213, 111, 0.8), rgba(40, 180, 133, 0.8)), url("../img/hero.jpg");
  background-size: cover;
  /* directly on replaced elements, e.g. <img>, <video>, you can use `object-fit` */
  background-position: top;
  /* tells which part of the bg should be "fixed" and will never go out of the frame */
  /* clip-path apply a "mask" in the object, you define the coordinate based on what you want to be shown on
   * screen - the `polygon` function receives coordinates to create as polygon shaped mask.
   * Fortunately, coordinates can be dynamic and passed as percentages */
  clip-path: polygon(0 0, 100% 0, 100% 75vh, 0 100%);
  /* position: relative; is like `static` but respects reference values from `top`, `left`, `bottom` and `right`,
   * and also can be used as "anchor" to child elements which have `position: absolute` */
  position: relative; }
  .header__logo-box {
    position: absolute;
    top: 4rem;
    /* relative to it's closest positioned parent, `.header` in this case */
    left: 4rem;
    /* relative to it's closest positioned parent, `.header` in this case */ }
  .header__logo {
    height: 3.5rem;
    /* by just setting `height` and omitting the `width`, this prop will be automatically figured out */ }
  .header__text-box {
    /* When you want to symmetrically center an element, just use flexbox prop on parents and child elements, but when
     * it's not gonna be 100% symmetrical, that's how you do it: */
    position: absolute;
    /* now it's positioned relative to it's closest positioned parent */
    top: 40%;
    /* relative to `.header` */
    left: 50%;
    /* relative to `.header` */
    /* as the element is positioned based on its top left corner, the prop bellow "makes it" be positioned based on
     * the element's center. Relative to the element's own position, it repositions it 50% (of its length) to the left
     * and 50% (of its height) to the top */
    transform: translate(-50%, -50%);
    text-align: center;
    /* this will make sure `.btn` element is centered */ }

/* Even though floats are not used anymore, it may be interesting to still know how these
 * work in case you have to update an old website that uses it to newer technologies */
.row {
  display: flow-root;
  max-width: 114rem;
  margin: 0 auto;
  /* I don't want this padding to change according to root font-size because in case its a bigger
   * font-size this padding would also become bigger and thus squash letters even more. */
  padding: 0 16px;
  /* [class^="col-"] selects all elements whose class attribute value starts with "col-"
   * actually is the `^` symbol that does this trick.
   * `^` --> starts with the declared value
   * `*` --> contains the declared value
   * `$` --> ends with the declared value */ }
  .row:not(:last-child) {
    margin-bottom: 8rem; }
  .row [class^="col-"] {
    float: left; }
    .row [class^="col-"]:not(:last-child) {
      margin-right: 6rem; }
  .row .col-1-of-2 {
    /* to use a sass variable within a native css function you MUST wrap that in # + { <var-here> } */
    width: calc((100% - 6rem)/2); }
  .row .col-1-of-3 {
    width: calc(calc(calc(100% - (3 - 1) * 6rem) / 3 * 1) + 0rem); }
  .row .col-2-of-3 {
    width: calc(calc(calc(100% - (3 - 1) * 6rem) / 3 * 2) + 6rem); }
  .row .col-1-of-4 {
    width: calc(calc(calc(100% - (4 - 1) * 6rem) / 4 * 1) + 0rem); }
  .row .col-2-of-4 {
    width: calc(calc(calc(100% - (4 - 1) * 6rem) / 4 * 2) + 6rem); }
  .row .col-3-of-4 {
    width: calc(calc(calc(100% - (4 - 1) * 6rem) / 4 * 3) + 12rem); }

/* in scss files within the pages folder (like this file), we can put style that could
 * be in the components folder but actually are going to appear only in this specific page */
.section-about {
  background-color: #f7f7f7;
  /* 8rem is the padding we want and +$margin-negative-indentation is to "cancel out" the
   * negative margin-top property set just bellow. In the end we're just doing that so the
   * background color of this element "flows" behind the element above this one.
   * (I looks like a hack to me, maybe there is a better way to do that...) */
  padding: calc(8rem + 20vh) 0 20vh;
  /* when you use negative values for margin instead of "expanding" outwards and pushing elements
   * around, it "expands" inwards and this way its box model gets smaller, thus the element gets
   * closer to other elements */
  margin-top: -20vh; }

.section-features {
  padding: 15rem 0;
  background-image: linear-gradient(to right bottom, rgba(126, 213, 111, 0.8), rgba(40, 180, 133, 0.8)), url("../img/nat-4.jpg");
  background-size: cover;
  margin-top: -12rem;
  transform: skewY(-7deg); }
  .section-features > * {
    transform: skewY(7deg); }

.section-tours {
  padding: calc(8rem + 8rem) 0 8rem;
  background-color: #f7f7f7;
  margin-top: -8rem; }
