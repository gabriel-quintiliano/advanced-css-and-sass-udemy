/*
COLORS:

Light green: #7ed56f
Medium green: #55c57a
Dark green: #28b485

*/

/* basic "global" reset */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box; /* margins and paddings are NOT added to the total size of the element */
}

body {
  /* everything related to "global" fonts should be done in the body tag selector, because
   * this way every element within <body> will inherit these style and its also more efficient
   * that doing the same via the `*` selector, which selects each element "individually", here
   * we're using the power of inheritance */

  font-family: "Lato", sans-serif; /* Use "Lato" font-family if available, otherwise use "sans-serif" */
  font-weight: 400;
  font-size: 16px;
  line-height: 1.7; /* now line-height will be 1.7x bigger than the pre-defined line-height*/
  color: #777; /* sets text color */
  padding: 30px; /* this padding will not be inherited by elements within <body> */
}

.header {
  /* the calc is to make it fits the viewport with 30px of padding above and bellow (added in <body>) */
  height: calc(98vh - (60px - 3vh)); /* 97% of the viewport height*/
  /* height: calc(97vh - 30px); 95% of the viewport height */
  /* always apply a gradient on the background via the `background-image` css prop, and if its the case
   * define the actual bg image afterwards, this way the gradient will be on top of the image - make sure
  * to correctly adjust the gradient opacity */
  background-image: linear-gradient(
      to right bottom,
      rgba(126, 213, 111, 0.8),
      rgba(40, 180, 131, 0.8)
    ),
    url("../img/hero.jpg");
  background-size: cover; /* directly on replaced elements, e.g. <img>, <video>, you can use `object-fit` */
  background-position: top; /* tells which part of the bg should be "fixed" and will never go out of the frame */

  /* clip-path apply a "mask" in the object, you define the coordinate based on what you want to be shown on
   * screen - the `polygon` function receives coordinates to create as polygon shaped mask.
   * Fortunately, coordinates can be dynamic and passed as percentages */
  clip-path: polygon(0 0, 100% 0, 100% 75vh, 0 100%);

  /* position: relative; is like `static` but respects reference values from `top`, `left`, `bottom` and `right`,
   * and also can be used as "anchor" to child elements which have `position: absolute` */
  position: relative;
}

.logo-box {
  position: absolute;
  top: 40px; /* relative to it's closest positioned parent, `.header` in this case */
  left: 40px; /* relative to it's closest positioned parent, `.header` in this case */
}

.logo {
  height: 35px; /* by just setting `height` and omitting the `width`, this prop will be automatically figured out */
}

.text-box {
  /* When you want to symmetrically center an element, just use flexbox prop on parents and child elements, but when
   * it's not gonna be 100% symmetrical, that's how you do it: */
  position: absolute; /* now it's positioned relative to it's closest positioned parent */
  top: 40%; /* relative to `.header` */
  left: 50%; /* relative to `.header` */
  /* as the element is positioned based on its top left corner, the prop bellow "makes it" be positioned based on
   * the element's center. Relative to the element's own position, it repositions it 50% (of its length) to the left
   * and 50% (of its height) to the top */
  transform: translate(-50%, -50%);
  text-align: center; /* this will make sure `.btn` element is centered */
}

.heading-primary {
  color: #fff;
  text-transform: uppercase;

  /* maybe this is needed if animations (of child elements of this) flick, this prop somehow fixes it */
  backface-visibility: hidden;
  margin-bottom: 60px;
}

.heading-primary-main {
  display: block;
  font-size: 60px;
  font-weight: 400;
  letter-spacing: 35px;

  animation-name: moveInLeft;
  animation-duration: 1.3s;
  animation-timing-function: ease-out;

  /*
  animation-delay: 3s; - delay for the animation to start
  animation-iteration-count: 3; - how many times should the animation be repeated
  */
}

.heading-primary-sub {
  display: block;
  font-size: 20px;
  font-weight: 700;
  letter-spacing: 17.4px;

  animation: moveInRight 1.3s ease-out; /* this is the shortcut for everything described bellow */
  /* animation-name: moveInRight;
  animation-duration: 1.3s;
  animation-timing-function: ease-out; */
}

/* regarding browser performance, it's better to only ever animate the `opacity` and `transform` properties
 * because these only trigger the `composite` phase of rendering the element on screen, the other phases,
 * `style`, `layout` (of elements) and `paint` are skipped.
 *
 * of course you can animate other properties, but remember that browser animations are only optimized for
 * `opacity` and `transform`. This video `https://www.youtube.com/watch?v=N5EW4HnF6FU` demonstrates this in
 * practice.
 *
 * for example when you deal with an element's width or margin you're also messing with the positioning of
 * the elements next to it and because of that, animations with those become less performant and look bad. */
@keyframes moveInLeft {
  0% {
    opacity: 0;
    /* translateX repositions the element on the x axis relative to its initial position */
    transform: translateX(-100px); /* the animation starts with the elem. 100px to the left */
  }
  
  80% {
    transform: translateX(10px);
  }
  
  100% {
    opacity: 1;
    transform: translateX(0); /* so the elem. is in its final position in the end of the animation */
  }
}

@keyframes moveInRight {
  0% {
    opacity: 0;
    transform: translateX(100px); /* the animation starts with the elem. 100px to the right */
  }
  
  80% {
    transform: translateX(-10px);
  }
  
  100% {
    opacity: 1;
    transform: translateX(0); /* so the elem. is in its final position in the end of the animation */
  }
}

/* :link pseudo-class represents an unvisited anchor tag */
.btn:link,
.btn:visited {
  text-transform: uppercase;
  text-decoration: none; /* gets rid of that default underline in anchor tags text content */
  padding: 15px 40px;
  /* by setting `display: inline-block` the inner-display prop = `inline` and because of that you can treat
   * this element as text (so it can be easily centered if its parent element has `text-align: center` set).
   * the `inline-block` value is necessary so there is a box model for us to deal with margins and paddings... */
  display: inline-block;
  border-radius: 7px;

  /* the `transition` property is a short-hand that will deal with the changing of style of an element,
   * so in the end it can be seen as another way to approach animations.
   * `transition` must always be set alongside the initial state styles.
   *
   * 1. define which css properties this transition will be applied to (if you don't know, use `all`)
   * 2. define the time this style transition will take (from initial state - define above - to final state
   *    which is in this case defined in `.btn:hover` and `.btn:active`) */
  transition: all .2s;
  position: relative;
}

.btn:hover {
  transform: translateY(-3px);
  box-shadow: 0 10px 20px rgba(0, 0, 0, .2); /* value = x-axis y-axis blur color */
}

/* :active pseudo-class represents an anchor tag that is being clicked (left button of mouse pressed) */
.btn:active {
  transform: translateY(-1px);
  box-shadow: 0 5px 10px rgba(0, 0, 0, .2); /* value = x-axis y-axis blur color */
}

.btn-white {
  background-color: #fff;
  color: #777;
}

/* ::after is a pseudo-element, which are virtual elements that are inserted as child-elements from the
 * real html element, these will only appear on screen if they have `display` or `content` set, and you
 * also need to define its `height` and `width` (remember, as these are within the real html element,
 * the 100% value refers to the whole size of this element)
 *  */
.btn::after {
  content: ""; /* it just need to have `content` set, it can even be empty */
  display: inline-block;
  height: 100%; /* refers to 100% of the `.btn` element */
  width: 100%; /* refers to 100% of the `.btn` element */
  border-radius: 7px;
  position: absolute; /* this prop + `top: 0;` and `left: 0;` positions this pseudo-elem right over `.btn` */
  top: 0;
  left: 0;
  transition: all .4s;
  z-index: -1; /* so it hinds behind `.btn` */
}

/* ::after pseudo-element when hovered */
.btn:hover::after {
  transform: scaleX(1.4) scaleY(1.6); /* scales this pseudo-element to twice its size */
  opacity: 0;
}

.btn-white::after {
  background-color: #fff;
}

.btn-animated {
  /* animation: <animation-name> <animation-duration> <animation-timing-function> <animation-delay> */
  animation: moveInBottom 0.65s ease-out .75s;

  /* `backwards` value already applies styles define in the first `@keyframes` animation rules (0% in this
   * case), during `animation-delay` (.75s in this case). */
  animation-fill-mode: backwards;
}

@keyframes moveInBottom {
  0% {
    opacity: 0;
    transform: translateY(30px); /* the animation starts with the elem. 100px to the right */
  }
  
  100% {
    opacity: 1;
    transform: translateY(0); /* so the elem. is in its final position in the end of the animation */
  }
}