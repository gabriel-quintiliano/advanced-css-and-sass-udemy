/*
COLORS:

Light green: #7ed56f
Medium green: #55c57a
Dark green: #28b485

*/

/* basic "global" reset */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box; /* margins and paddings are NOT added to the total size of the element */
}

body {
  /* everything related to "global" fonts should be done in the body tag selector, because
   * this way every element within <body> will inherit these style and its also more efficient
   * that doing the same via the `*` selector, which selects each element "individually", here
   * we're using the power of inheritance */

  font-family: "Lato", sans-serif; /* Use "Lato" font-family if available, otherwise use "sans-serif" */
  font-weight: 400;
  font-size: 16px;
  line-height: 1.7; /* now line-height will be 1.7x bigger than the pre-defined line-height*/
  color: #777; /* sets text color */
  padding: 30px; /* this padding will not be inherited by elements within <body> */
}

.header {
  /* the calc is to make it fits the viewport with 30px of padding above and bellow (added in <body>) */
  height: calc(98vh - (60px - 3vh)); /* 97% of the viewport height*/
  /* height: calc(97vh - 30px); 95% of the viewport height */
  /* always apply a gradient on the background via the `background-image` css prop, and if its the case
   * define the actual bg image afterwards, this way the gradient will be on top of the image - make sure
  * to correctly adjust the gradient opacity */
  background-image: linear-gradient(
      to right bottom,
      rgba(126, 213, 111, 0.8),
      rgba(40, 180, 131, 0.8)
    ),
    url("../img/hero.jpg");
  background-size: cover; /* directly on replaced elements, e.g. <img>, <video>, you can use `object-fit` */
  background-position: top; /* tells which part of the bg should be "fixed" and will never go out of the frame */

  /* clip-path apply a "mask" in the object, you define the coordinate based on what you want to be shown on
   * screen - the `polygon` function receives coordinates to create as polygon shaped mask.
   * Fortunately, coordinates can be dynamic and passed as percentages */
  clip-path: polygon(0 0, 100% 0, 100% 75vh, 0 100%);

  /* position: relative; is like `static` but respects reference values from `top`, `left`, `bottom` and `right`,
   * and also can be used as "anchor" to child elements which have `position: absolute` */
  position: relative;
}

.logo-box {
  position: absolute;
  top: 40px; /* relative to it's closest positioned parent, `.header` in this case */
  left: 40px; /* relative to it's closest positioned parent, `.header` in this case */
}

.logo {
  height: 35px; /* by just setting `height` and omitting the `width`, this prop will be automatically figured out */
}

.text-box {
  /* When you want to symmetrically center an element, just use flexbox prop on parents and child elements, but when
   * it's not gonna be 100% symmetrical, that's how you do it: */
  position: absolute; /* now it's positioned relative to it's closest positioned parent */
  top: 40%; /* relative to `.header` */
  left: 50%; /* relative to `.header` */
  /* as the element is positioned based on its top left corner, the prop bellow "makes it" be positioned based on
   * the element's center. Relative to the element's own position, it repositions it 50% (of its length) to the left
   * and 50% (of its height) to the top */
  transform: translate(-50%, -50%);
}

.heading-primary {
  color: #fff;
  text-transform: uppercase;

  /* maybe this is needed if animations (of child elems of this) flick, this prop somehow fixes it */
  backface-visibility: hidden;
}

.heading-primary-main {
  display: block;
  font-size: 60px;
  font-weight: 400;
  letter-spacing: 35px;

  animation-name: moveInLeft;
  animation-duration: 1.3s;
  animation-timing-function: ease-out;

  /*
  animation-delay: 3s; - delay for the animation to start
  animation-iteration-count: 3; - how many times should the animation be repeated
  */
}

.heading-primary-sub {
  display: block;
  font-size: 20px;
  font-weight: 700;
  letter-spacing: 17.4px;

  animation: moveInRight 1.3s ease-out; /* this is the shortcut for everything described bellow */
  /* animation-name: moveInRight;
  animation-duration: 1.3s;
  animation-timing-function: ease-out; */
}

/* regarding browser performance, it's better to only ever animate the `opacity` and `transform` properties
 * because these only trigger the `composite` phase of rendering the element on screen, the other phases,
 * `style`, `layout` (of elements) and `paint` are skipped.
 *
 * of course you can animate other properties, but remember that browser animations are only optimized for
 * `opacity` and `transform`. This video `https://www.youtube.com/watch?v=N5EW4HnF6FU` demonstrates this in
 * practice.
 *
 * for example when you deal with an element's width or margin you're also messing with the positioning of
 * the elements next to it and because of that, animations with those become less performant and look bad. */
@keyframes moveInLeft {
  0% {
    opacity: 0;
    /* translateX repositions the element on the x axis relative to its initial position */
    transform: translateX(-100px); /* the animation starts with the elem. 100px to the left */
  }
  
  80% {
    transform: translateX(10px);
  }
  
  100% {
    opacity: 1;
    transform: translateX(0); /* so the elem. is in its final position in the end of the animation */
  }
}

@keyframes moveInRight {
  0% {
    opacity: 0;
    transform: translateX(100px); /* the animation starts with the elem. 100px to the right */
  }
  
  80% {
    transform: translateX(-10px);
  }
  
  100% {
    opacity: 1;
    transform: translateX(0); /* so the elem. is in its final position in the end of the animation */
  }
}